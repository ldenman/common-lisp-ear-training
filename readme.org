This is my experminetal pet project and is not meant for public use IMHO.

You may be interested in some other Common Lisp music libraries below:
  - https://github.com/MegaLoler/Music

* Background
  #+begin_quote
  "This program is ugly, dirty, disgusting, not the way I would write this as a professional. It is written with concrete syntax, meaning I'm going to use lots of cars and cdrs..."
    -- Gerald Jay Sussman (https://youtu.be/aAlR3cezPJg?t=339)
  #+end_quote

This project is my exploration in representing musical information with LISP.

What kind of musical information is there to represent? To start... *Notes, Scales, and Chords.*

- *Notes* - the most basic unit of musical pitch information.
  These are currently represented as integers (MIDI) and symbolically as moveable-do solfege like (DO RE MI) and absolute name "C4" where "C" is the note and "4" is the octave on the keyboard.
- *Scales* - collections of notes based on scale patterns (major, minor, etc)
- *Chords* - collections of notes usually derived from a scale

This program deals only with the notes on a standard 88 key piano as limiting the notes to 88 seems to be practical at this time.

** High level ideas

  The piano is a _list_ of 88 notes.  From this structure we can
  derive all sorts of musical structures.

  I'm interested in tonal structures... the major and minor scales,
  diatonic chords derived from those scales, and ear training
  concepts.

  In general, I want to create musical structure with commonly used
  symbols, the same ones used in music theory and ear training
  classes...

  Specifically, I want *solfege* symbols to reference scale and chord tones, such as:
  
  - Ex.) The major scale in solfege: DO RE MI FA SO LA TI DO
  - Ex.) The nat. minor scale in solfege: DO RE ME FA SO SE LE TE DO
  - Ex.) The asc. chromatic scale: DO DI RE RI MI FA FI SO SI LA LI TI DO
  - Ex.) The desc. chromatic scale: DO TI TE LA LE SO SE FA MI ME RE RA DO

  I also want symbols for referring to diatonic chords. In music
  theory and ear training chords are usually referred to by Roman
  Numerals:

  - Ex.) The most common chord progression: I V VI- IV
  - Ex.) The plagal cadence: I IV I
  - Ex.) The cycle V progression: I IV VII III- VI- III- V I

* Dependencies
** quicklisp
- https://www.quicklisp.org/beta/#installation
** *sbcl* dependent
- I am using SBCL and the #'schedule fn (in sequencer.lisp) spawns a thread. I believe the thread functionality is SBCL dependent.
- The use of #'sb-ext:seed-random-state function is SBCL dependent

** portmidi - Download it locally
This depends on the *portmidi* library to play midi in-memory to a
hardware or software midi device of your choosing.

  - https://github.com/chfin/cl-portmidi
  - cd ~/quicklisp/local-projects
  - git clone https://github.com/chfin/cl-portmidi.git

** midi library - Download it locally
The MIDI library provides the ability to read/write midi files.

  - cd ~/quicklisp/local-projects
  - git clone https://github.com/ldenman/midi
    
* Setup
** Qsynth settings
I am using the Qsynth software synth with following settings YMMV:

- MIDI
  - MIDI DRIVER: alsa_seq
- AUDIO
  - AUDIO DRIVER: jack

** Load project
#+begin_src lisp
    (ql:quickload "ld-music")
    (in-package :ld-music)
#+end_src

#+RESULTS:
: #<PACKAGE "LD-MUSIC">

** Emacs Integrations
   
*** project reloading functions
I have these functions in my ~/.emacs file to quickly reload the project:

   #+begin_src elisp
     (defun ld-music-reload ()
       (interactive)
       (ld-music-unload)
       (ld-music-load))

     (defun ld-music-unload ()
       (interactive)
       (when (slime-connected-p)
	 (slime-eval '(ld-music:midi-unload))))

     (defun ld-music-unload-hard ()
       (interactive)
       (when (slime-connected-p)
	 (slime-quit-lisp)
	 (sit-for 1)
	 (slime-kill-all-buffers)
	 (sit-for 1)))

     (defun ld-music-load ()
       (interactive)
       (if (not (slime-connected-p)) (slime))
       (sit-for 1)
       (when (slime-eval '(ql:quickload "ld-music"))
	 (sit-for 1)
	 (slime-eval-async '(ld-music:setup-midi))))
   #+end_src

*** project testing functions
    #+begin_src elisp
      (defun ld-music-runtests ()
	(interactive)
	(princ (slime-eval '(ld-music:run-tests))))

      (define-minor-mode ld-music-test-mode
	"ld-music-test-mode")

      (defun ld-music-test ()
	"run ld-music tests"
	(when ld-music-test-mode
	  (ld-music-runtest)))

      (add-hook 'after-save-hook #'ld-music-test)
    #+end_src
* MIDI Smoke testing
** List the midi devices available on your system:

  #+begin_src lisp  :package ld-music
    (pm:list-devices)
  #+end_src

  #+RESULTS:
  : ((0 . ALSA | Midi Through Port-0 | input: NIL | output: T) (1 . ALSA | Midi Through Port-0 | input: T | output: NIL) (2 . ALSA | Roland Digital Piano MIDI 1 | input: NIL | output: T) (3 . ALSA | Roland Digital Piano MIDI 1 | input: T | output: NIL))


  Find your MIDI device where output: T and copy the Integer.
  For example, my device is (2 . ALSA | Roland Digital Piano MIDI 1 | input: NIL | output: T)
  
** Initialize the midi device and smoke test
   
  #+begin_src lisp :package ld-music
    (pm-initialize 2)
  #+end_src

  #+RESULTS:
  : #.(SB-SYS:INT-SAP #X55AE35D700D0)

You should hear a note play when you run #'smoke-test.

  #+begin_src lisp :package ld-music
    (smoke-test)
  #+end_src

  #+RESULTS:
  : NIL

* DATA FORMATS

- NOTE :: an ALIST grouping TYPE, NAME, VALUE, SOLFEGE, OCTAVE
- SCALE :: an ALIST grouping NOTES and SCALE TEMPLATE
- SCALE TEMPLATE :: a list of scale steps/solfege pairs used to realize scales
- CHORD :: a list of CHORD-TONES
- CHORD-TONE :: an ALIST grouping TYPE, NOTE, DEGREE
- SCALE-CHORD :: an ALIST grouping SCALE, CHORDS, ROMAN-NUMERAL-CHORDS 
- RHYTHMIC-NOTE :: a pairing of NOTE and RHYTHM-VALUE where RHYTHM-VALUE is 1,2,4,8,16
- EVENT :: an ALIST grouping NOTE, ON-TIME, OFF-TIME, VELOCITY

* Concepts
  
** Notes

A note is technically a frequency like "A 440HZ". But in this program a note is represented as an ALIST with following attributes:

- TYPE :: The type of the object (NOTE)
- NAME :: The absolute name of the note on the keyboard
- VALUE :: The MIDI Value
- OCTAVE :: The keyboard octave
- SOLFEGE :: The solfege syllable assigned to the note

#+begin_src lisp :package ld-music :exports both
(make-note 'A4 69 nil)
#+end_src

#+RESULTS:
: ((TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE) (OCTAVE . 4))

** Scale templates

Scale templates are represented by a list of pairs (X . Y) where *X* is
either W or H, representing 1 semitone or 2 semitones, respectivley and *Y* is a solfege syllable (ie. *DO*).
*Y* may also be a LIST of enharmonic solfege syllables such as '(*DI RA*) or '(*FI SE*).

- W :: represents 1 semitone
- H :: represents 2 semitones

This scale template is used to "realize" scales, stepping and
collecting notes according to the semitone pattern (ie W W H W W W H)
and assigning a solfege syllable (or list of enharmonic solfa) to the
note.

*** Usage
Making a scale template is done like so:

#+begin_src lisp :package ld-music :exports both
  (make-scale-template '(w w h w w w h)
		       '(do re mi fa so la ti do) )
#+end_src

#+RESULTS:
: ((W . DO) (W . RE) (H . MI) (W . FA) (W . SO) (W . LA) (H . TI))

Some scale templates are defined as functions:

- Chromatic scale template uses enharmonic solfa:
  #+begin_src lisp :package ld-music :exports both
  (chromatic-scale-template)
  #+end_src

  #+RESULTS:
  : ((H . DO) (H DI RA) (H . RE) (H RI ME) (H . MI) (H . FA) (H FI SE) (H . SO) (H SI LE) (H . LA) (H LI TE) (H . TI))

- Minor scale template
  #+begin_src lisp :package ld-music :exports both
    (minor-scale-template)
  #+end_src

  #+RESULTS:
  : ((W . DO) (H . RE) (W . ME) (W . FA) (H . SO) (W . LE) (W . TE))

- Dorian scale template
  #+begin_src lisp :package ld-music :exports both
    (dorian-scale-template)
  #+end_src

  #+RESULTS:
  : ((W . DO) (H . RE) (W . ME) (W . FA) (W . SO) (H . LA) (W . TI))

** Scales

Scales are represented as ALISTS containing LIST of NOTES and a SCALE-TEMPLATE.

- NOTES :: A LIST of NOTES
- TEMPLATE :: The scale template used to realize the notes; defaults to the *major-scale-template*

*** Usage

**** #'make-scale
The #'make-scale function is used to create scales from a template. The default scale template is the major scale. 

  #+begin_src lisp :package ld-music :exports code
  (make-scale 'c4)
  #+end_src

  #+RESULTS:
  | NOTES    | ((TYPE . NOTE) (NAME . A0) (VALUE . 21) (SOLFEGE . LA) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . B0) (VALUE . 23) (SOLFEGE . TI) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . C0) (VALUE . 24) (SOLFEGE . DO) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . D0) (VALUE . 26) (SOLFEGE . RE) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . E0) (VALUE . 28) (SOLFEGE . MI) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . F0) (VALUE . 29) (SOLFEGE . FA) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . G0) (VALUE . 31) (SOLFEGE . SO) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . A1) (VALUE . 33) (SOLFEGE . LA) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . B1) (VALUE . 35) (SOLFEGE . TI) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . C1) (VALUE . 36) (SOLFEGE . DO) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . D1) (VALUE . 38) (SOLFEGE . RE) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . E1) (VALUE . 40) (SOLFEGE . MI) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . F1) (VALUE . 41) (SOLFEGE . FA) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . G1) (VALUE . 43) (SOLFEGE . SO) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . A2) (VALUE . 45) (SOLFEGE . LA) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . B2) (VALUE . 47) (SOLFEGE . TI) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . C2) (VALUE . 48) (SOLFEGE . DO) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . D2) (VALUE . 50) (SOLFEGE . RE) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . E2) (VALUE . 52) (SOLFEGE . MI) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . F4) (VALUE . 77) (SOLFEGE . FA) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . G4) (VALUE . 79) (SOLFEGE . SO) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . A5) (VALUE . 81) (SOLFEGE . LA) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . B5) (VALUE . 83) (SOLFEGE . TI) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . C5) (VALUE . 84) (SOLFEGE . DO) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . D5) (VALUE . 86) (SOLFEGE . RE) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . E5) (VALUE . 88) (SOLFEGE . MI) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . F5) (VALUE . 89) (SOLFEGE . FA) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . G5) (VALUE . 91) (SOLFEGE . SO) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . A6) (VALUE . 93) (SOLFEGE . LA) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . B6) (VALUE . 95) (SOLFEGE . TI) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . C6) (VALUE . 96) (SOLFEGE . DO) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . D6) (VALUE . 98) (SOLFEGE . RE) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . E6) (VALUE . 100) (SOLFEGE . MI) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . F6) (VALUE . 101) (SOLFEGE . FA) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . G6) (VALUE . 103) (SOLFEGE . SO) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . A7) (VALUE . 105) (SOLFEGE . LA) (OCTAVE . 7)) | ((TYPE . NOTE) (NAME . B7) (VALUE . 107) (SOLFEGE . TI) (OCTAVE . 7)) | ((TYPE . NOTE) (NAME . C7) (VALUE . 108) (SOLFEGE . DO) (OCTAVE . 7)) |
  | TEMPLATE | (W . DO)                                                             | (W . RE)                                                             | (H . MI)                                                             | (W . FA)                                                             | (W . SO)                                                             | (W . LA)                                                             | (H . TI)                                                             |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                       |                                                                       |                                                                       |                                                                       |                                                                       |                                                                       |
  #+begin_src lisp :package ld-music :exports code
  (make-scale 'c4 (chromatic-scale-template))
  #+end_src

  #+RESULTS:
  #+begin_example
  ((NOTES ((TYPE . NOTE) (NAME . A0) (VALUE . 21) (SOLFEGE . LA) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |A#0|) (VALUE . 22) (SOLFEGE LI TE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . B0) (VALUE . 23) (SOLFEGE . TI) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . C0) (VALUE . 24) (SOLFEGE . DO) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |C#0|) (VALUE . 25) (SOLFEGE DI RA) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . D0) (VALUE . 26) (SOLFEGE . RE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |D#0|) (VALUE . 27) (SOLFEGE RI ME) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . E0) (VALUE . 28) (SOLFEGE . MI) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . F0) (VALUE . 29) (SOLFEGE . FA) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |F#0|) (VALUE . 30) (SOLFEGE FI SE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . G0) (VALUE . 31) (SOLFEGE . SO) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |G#0|) (VALUE . 32) (SOLFEGE SI LE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . A1) (VALUE . 33) (SOLFEGE . LA) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |A#1|) (VALUE . 34) (SOLFEGE LI TE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . B1) (VALUE . 35) (SOLFEGE . TI) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . C1) (VALUE . 36) (SOLFEGE . DO) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |C#1|) (VALUE . 37) (SOLFEGE DI RA) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . D1) (VALUE . 38) (SOLFEGE . RE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |D#1|) (VALUE . 39) (SOLFEGE RI ME) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . E1) (VALUE . 40) (SOLFEGE . MI) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . F1) (VALUE . 41) (SOLFEGE . FA) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |F#1|) (VALUE . 42) (SOLFEGE FI SE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . G1) (VALUE . 43) (SOLFEGE . SO) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |G#1|) (VALUE . 44) (SOLFEGE SI LE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . A2) (VALUE . 45) (SOLFEGE . LA) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |A#2|) (VALUE . 46) (SOLFEGE LI TE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . B2) (VALUE . 47) (SOLFEGE . TI) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . C2) (VALUE . 48) (SOLFEGE . DO) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |C#2|) (VALUE . 49) (SOLFEGE DI RA) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . D2) (VALUE . 50) (SOLFEGE . RE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |D#2|) (VALUE . 51) (SOLFEGE RI ME) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . E2) (VALUE . 52) (SOLFEGE . MI) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |F#2|) (VALUE . 54) (SOLFEGE FI SE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |G#2|) (VALUE . 56) (SOLFEGE SI LE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |A#3|) (VALUE . 58) (SOLFEGE LI TE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |C#3|) (VALUE . 61) (SOLFEGE DI RA) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |D#3|) (VALUE . 63) (SOLFEGE RI ME) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |F#3|) (VALUE . 66) (SOLFEGE FI SE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |G#3|) (VALUE . 68) (SOLFEGE SI LE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |A#4|) (VALUE . 70) (SOLFEGE LI TE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |C#4|) (VALUE . 73) (SOLFEGE DI RA) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |D#4|) (VALUE . 75) (SOLFEGE RI ME) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . F4) (VALUE . 77) (SOLFEGE . FA) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |F#4|) (VALUE . 78) (SOLFEGE FI SE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . G4) (VALUE . 79) (SOLFEGE . SO) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |G#4|) (VALUE . 80) (SOLFEGE SI LE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . A5) (VALUE . 81) (SOLFEGE . LA) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |A#5|) (VALUE . 82) (SOLFEGE LI TE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . B5) (VALUE . 83) (SOLFEGE . TI) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . C5) (VALUE . 84) (SOLFEGE . DO) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |C#5|) (VALUE . 85) (SOLFEGE DI RA) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . D5) (VALUE . 86) (SOLFEGE . RE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |D#5|) (VALUE . 87) (SOLFEGE RI ME) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . E5) (VALUE . 88) (SOLFEGE . MI) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . F5) (VALUE . 89) (SOLFEGE . FA) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |F#5|) (VALUE . 90) (SOLFEGE FI SE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . G5) (VALUE . 91) (SOLFEGE . SO) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |G#5|) (VALUE . 92) (SOLFEGE SI LE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . A6) (VALUE . 93) (SOLFEGE . LA) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |A#6|) (VALUE . 94) (SOLFEGE LI TE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . B6) (VALUE . 95) (SOLFEGE . TI) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . C6) (VALUE . 96) (SOLFEGE . DO) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |C#6|) (VALUE . 97) (SOLFEGE DI RA) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . D6) (VALUE . 98) (SOLFEGE . RE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |D#6|) (VALUE . 99) (SOLFEGE RI ME) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . E6) (VALUE . 100) (SOLFEGE . MI) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . F6) (VALUE . 101) (SOLFEGE . FA) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |F#6|) (VALUE . 102) (SOLFEGE FI SE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . G6) (VALUE . 103) (SOLFEGE . SO) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |G#6|) (VALUE . 104) (SOLFEGE SI LE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . A7) (VALUE . 105) (SOLFEGE . LA) (OCTAVE . 7))
    ((TYPE . NOTE) (NAME . |A#7|) (VALUE . 106) (SOLFEGE LI TE) (OCTAVE . 7))
    ((TYPE . NOTE) (NAME . B7) (VALUE . 107) (SOLFEGE . TI) (OCTAVE . 7))
    ((TYPE . NOTE) (NAME . C7) (VALUE . 108) (SOLFEGE . DO) (OCTAVE . 7)))
   (TEMPLATE (H . DO) (H DI RA) (H . RE) (H RI ME) (H . MI) (H . FA) (H FI SE)
    (H . SO) (H SI LE) (H . LA) (H LI TE) (H . TI)))
  #+end_example

  #+begin_src lisp :package ld-music :exports code
  (make-scale 'c4 (minor-scale-template))
  #+end_src

  #+RESULTS:
  #+begin_example
  ((NOTES ((TYPE . NOTE) (NAME . |A#0|) (VALUE . 22) (SOLFEGE . TE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . C0) (VALUE . 24) (SOLFEGE . DO) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . D0) (VALUE . 26) (SOLFEGE . RE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |D#0|) (VALUE . 27) (SOLFEGE . ME) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . F0) (VALUE . 29) (SOLFEGE . FA) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . G0) (VALUE . 31) (SOLFEGE . SO) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |G#0|) (VALUE . 32) (SOLFEGE . LE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |A#1|) (VALUE . 34) (SOLFEGE . TE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . C1) (VALUE . 36) (SOLFEGE . DO) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . D1) (VALUE . 38) (SOLFEGE . RE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |D#1|) (VALUE . 39) (SOLFEGE . ME) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . F1) (VALUE . 41) (SOLFEGE . FA) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . G1) (VALUE . 43) (SOLFEGE . SO) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |G#1|) (VALUE . 44) (SOLFEGE . LE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |A#2|) (VALUE . 46) (SOLFEGE . TE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . C2) (VALUE . 48) (SOLFEGE . DO) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . D2) (VALUE . 50) (SOLFEGE . RE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |D#2|) (VALUE . 51) (SOLFEGE . ME) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |G#2|) (VALUE . 56) (SOLFEGE . LE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |A#3|) (VALUE . 58) (SOLFEGE . TE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |D#3|) (VALUE . 63) (SOLFEGE . ME) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |G#3|) (VALUE . 68) (SOLFEGE . LE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |A#4|) (VALUE . 70) (SOLFEGE . TE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |D#4|) (VALUE . 75) (SOLFEGE . ME) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . F4) (VALUE . 77) (SOLFEGE . FA) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . G4) (VALUE . 79) (SOLFEGE . SO) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |G#4|) (VALUE . 80) (SOLFEGE . LE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |A#5|) (VALUE . 82) (SOLFEGE . TE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . C5) (VALUE . 84) (SOLFEGE . DO) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . D5) (VALUE . 86) (SOLFEGE . RE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |D#5|) (VALUE . 87) (SOLFEGE . ME) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . F5) (VALUE . 89) (SOLFEGE . FA) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . G5) (VALUE . 91) (SOLFEGE . SO) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |G#5|) (VALUE . 92) (SOLFEGE . LE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |A#6|) (VALUE . 94) (SOLFEGE . TE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . C6) (VALUE . 96) (SOLFEGE . DO) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . D6) (VALUE . 98) (SOLFEGE . RE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |D#6|) (VALUE . 99) (SOLFEGE . ME) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . F6) (VALUE . 101) (SOLFEGE . FA) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . G6) (VALUE . 103) (SOLFEGE . SO) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |G#6|) (VALUE . 104) (SOLFEGE . LE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |A#7|) (VALUE . 106) (SOLFEGE . TE) (OCTAVE . 7))
    ((TYPE . NOTE) (NAME . C7) (VALUE . 108) (SOLFEGE . DO) (OCTAVE . 7)))
   (TEMPLATE (W . DO) (H . RE) (W . ME) (W . FA) (H . SO) (W . LE) (W . TE)))
  #+end_example

**** #'scale-notes

Returns a list of all scale notes.

  #+begin_src lisp :package ld-music :exports both
  (take 12 (scale-notes (make-scale 'c4)))
  #+end_src

  #+RESULTS:
  | (TYPE . NOTE) | (NAME . A0) | (VALUE . 21) | (SOLFEGE . LA) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . B0) | (VALUE . 23) | (SOLFEGE . TI) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . C0) | (VALUE . 24) | (SOLFEGE . DO) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . D0) | (VALUE . 26) | (SOLFEGE . RE) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . E0) | (VALUE . 28) | (SOLFEGE . MI) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . F0) | (VALUE . 29) | (SOLFEGE . FA) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . G0) | (VALUE . 31) | (SOLFEGE . SO) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . A1) | (VALUE . 33) | (SOLFEGE . LA) | (OCTAVE . 1) |
  | (TYPE . NOTE) | (NAME . B1) | (VALUE . 35) | (SOLFEGE . TI) | (OCTAVE . 1) |
  | (TYPE . NOTE) | (NAME . C1) | (VALUE . 36) | (SOLFEGE . DO) | (OCTAVE . 1) |
  | (TYPE . NOTE) | (NAME . D1) | (VALUE . 38) | (SOLFEGE . RE) | (OCTAVE . 1) |
  | (TYPE . NOTE) | (NAME . E1) | (VALUE . 40) | (SOLFEGE . MI) | (OCTAVE . 1) |

**** #'scale-range
Returns a new scale object containing a subset of notes

  #+begin_src lisp :package ld-music :exports both
    (scale-notes (scale-range 'c3 'c4  (make-scale 'c4)))
  #+end_src

  #+RESULTS:
  | (TYPE . NOTE) | (NAME . C3) | (VALUE . 60) | (SOLFEGE . DO) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . D3) | (VALUE . 62) | (SOLFEGE . RE) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . E3) | (VALUE . 64) | (SOLFEGE . MI) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . F3) | (VALUE . 65) | (SOLFEGE . FA) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . G3) | (VALUE . 67) | (SOLFEGE . SO) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . A4) | (VALUE . 69) | (SOLFEGE . LA) | (OCTAVE . 4) |
  | (TYPE . NOTE) | (NAME . B4) | (VALUE . 71) | (SOLFEGE . TI) | (OCTAVE . 4) |
  | (TYPE . NOTE) | (NAME . C4) | (VALUE . 72) | (SOLFEGE . DO) | (OCTAVE . 4) |

**** #'note-range
Returns a subset of notes according to a specified range

  #+begin_src lisp :package ld-music :exports both
    (note-range 'c3 'c4  (scale-notes (make-scale 'c4)))
  #+end_src

  #+RESULTS:
  | (TYPE . NOTE) | (NAME . C3) | (VALUE . 60) | (SOLFEGE . DO) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . D3) | (VALUE . 62) | (SOLFEGE . RE) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . E3) | (VALUE . 64) | (SOLFEGE . MI) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . F3) | (VALUE . 65) | (SOLFEGE . FA) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . G3) | (VALUE . 67) | (SOLFEGE . SO) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . A4) | (VALUE . 69) | (SOLFEGE . LA) | (OCTAVE . 4) |
  | (TYPE . NOTE) | (NAME . B4) | (VALUE . 71) | (SOLFEGE . TI) | (OCTAVE . 4) |
  | (TYPE . NOTE) | (NAME . C4) | (VALUE . 72) | (SOLFEGE . DO) | (OCTAVE . 4) |


**** #'scale-octaves
Returns an list of pairs (X . Y) where X is a NOTE and Y is an INTEGER
value representing an *octave relative to the scale*.  The idea is
that there is *absolute octaves* and *relative octaves*.

- Absolute is what the piano octaves are like "C4" or "A#7". Absolute isn't related to a key center.
- Relative octaves are relative to the key center/scale... meaning that *a new octave starts on the tonic note*.

  #+begin_src lisp :package ld-music :exports pp
    (take 3 (scale-octaves (scale-notes (make-scale 'c4))))
  #+end_src

  #+RESULTS:
  : ((((TYPE . NOTE) (NAME . A0) (VALUE . 21) (SOLFEGE . LA) (OCTAVE . 0)) . 0) (((TYPE . NOTE) (NAME . B0) (VALUE . 23) (SOLFEGE . TI) (OCTAVE . 0)) . 0) (((TYPE . NOTE) (NAME . C0) (VALUE . 24) (SOLFEGE . DO) (OCTAVE . 0)) . 1))

**** #'with-scale macro
     
** Chord

** Chord Tones

** Scale Chords
Scales and chords are two sides of the same coin.

*Scale chords* provide an object with access to chords and the scale from which they derived.

- Scale :: the scale
- Chords :: the list of chords
- Roman Numberal Chords :: an ALIST associating a roman numeral with the chord

* Data and Functions

The initial and most fundamental data we have is a list of MIDI INTEGERS (21..108)

#+begin_src lisp :package ld-music
  (midi-integers)
#+end_src

#+RESULTS:
| 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 |

Then there is the #'midi-note-octave list of absolute note names and octave

 #+begin_src lisp :package ld-music
   (midi-note-octave)
 #+end_src

 #+RESULTS:
 : (A0 |A#0| B0 C0 |C#0| D0 |D#0| E0 F0 |F#0| G0 |G#0| A1 |A#1| B1 C1 |C#1| D1
 :  |D#1| E1 F1 |F#1| G1 |G#1| A2 |A#2| B2 C2 |C#2| D2 |D#2| E2 F2 |F#2| G2 |G#2|
 :  A3 |A#3| B3 C3 |C#3| D3 |D#3| E3 F3 |F#3| G3 |G#3| A4 |A#4| B4 C4 |C#4| D4
 :  |D#4| E4 F4 |F#4| G4 |G#4| A5 |A#5| B5 C5 |C#5| D5 |D#5| E5 F5 |F#5| G5 |G#5|
 :  A6 |A#6| B6 C6 |C#6| D6 |D#6| E6 F6 |F#6| G6 |G#6| A7 |A#7| B7 C7)

 #+begin_src lisp  :package ld-music
   (first (midi-note-octave)) ; A0
   (last (midi-note-octave))  ; (C7)
   (length (midi-note-octave)); 88
 #+end_src

The  #'midi-notes function turns the MIDI integers and absolute note names into the NOTE data structure

#+begin_src lisp  :package ld-music
  (first (midi-notes)); ((TYPE . NOTE) (NAME . A0) (VALUE . 21) (SOLFEGE) (OCTAVE . 0))
  (last (midi-notes)); (((TYPE . NOTE) (NAME . C7) (VALUE . 108) (SOLFEGE) (OCTAVE . 7))) 
  (length (midi-notes)); 88
#+end_src

At this point, we have a basic representation of all notes on the keyboard.
The next step is to build scales.

*Scale templates* are used to realize scales from the patterns they
define. For example, The major scale uses a pattern of "W W H W W W H"
where W is 2 semitones and H is 1 semitone.

The #'make-scale-template function is used to make *scale templates*.

To define the major scale template, set the pattern and the solfege
syllables:

#+begin_src lisp  :package ld-music
  (make-scale-template '(w w h w w w h) '(do re mi fa so la ti do))
#+end_src

#+RESULTS:
: ((W . DO) (W . RE) (H . MI) (W . FA) (W . SO) (W . LA) (H . TI))

To realize the scale, use the *#'make-scale-from-template* function.

The algorithm looks at all notes available and returns only the notes
found according to the scale pattern.

The function signature requires a starting note and end note.

To creates a C major scale from C4 to C5:
#+begin_src lisp  :package ld-music
  (let ((major-scale-template
	  (make-scale-template '(w w h w w w h)
			       '(do re mi fa so la ti do))))
    (make-scale-from-template 'C4 'C5 major-scale-template))
#+end_src

#+RESULTS:
| (TYPE . NOTE) | (NAME . C4) | (VALUE . 72) | (SOLFEGE . DO) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . D4) | (VALUE . 74) | (SOLFEGE . RE) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . E4) | (VALUE . 76) | (SOLFEGE . MI) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . F4) | (VALUE . 77) | (SOLFEGE . FA) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . G4) | (VALUE . 79) | (SOLFEGE . SO) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . A5) | (VALUE . 81) | (SOLFEGE . LA) | (OCTAVE . 5) |
| (TYPE . NOTE) | (NAME . B5) | (VALUE . 83) | (SOLFEGE . TI) | (OCTAVE . 5) |
| (TYPE . NOTE) | (NAME . C5) | (VALUE . 84) | (SOLFEGE . DO) | (OCTAVE . 5) |

Each item in the list is a NOTE -- an ALIST representing SOLFEGENAME,
NOTENAME, MIDI-VALUE, and KEYBOARD OCTAVE.

The functions #'note-name, #'note-value, #'note-solfege are used to
select note data.

** CHORDS
The next logical step would be to build up chords.

The C Major scale notes are C D E F G A B. To make chords, you combine every other note in scale:

The triads in C major are "CEG" "DFA" "EGB" "FAC" "GBD" "ACE" "BDF".

The seventh chords in C major are "CEGA" "DFAG" "EGBD" "FACE" "GBDF" "ACEG" "BDFA".

Use the #'chord-builder function to generate a list of chords.

*#'chord-builder* takes a scale and generates a list of chords up the
the 13th (remember, a chord is just a list of notes)

#+begin_src lisp :package ld-music
  (take 7 (let* ((c-major-scale
	   (make-scale-from-template 'C2 'G4
				     (make-scale-template '(w w h w w w h)
							  '(do re mi fa so la ti do)))))
    (chord-builder c-major-scale)))
#+end_src

#+RESULTS:
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C2) (VALUE . 48) (SOLFEGE . DO) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E2) (VALUE . 52) (SOLFEGE . MI) (OCTAVE . 2)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D2) (VALUE . 50) (SOLFEGE . RE) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E2) (VALUE . 52) (SOLFEGE . MI) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F4) (VALUE . 77) (SOLFEGE . FA) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G4) (VALUE . 79) (SOLFEGE . SO) (OCTAVE . 4)) (DEGREE . 13)) |

*** Triads and Sevenths
The *#'triads* and *#'sevenths* functions take a list of chords and reduce
each chord to a specific number of notes, 3 and 4 respectively.

The *#'chord-take function* takes an integer and list of chords and returns a shortened list.

#+begin_example
  (car (triads (test-chord-builder))) 
#+end_example
: => (((C2 . 48) . DO) ((E2 . 52) . MI) ((G2. 55) . SO))

#+begin_example
  (car (sevenths (test-chord-builder)))
#+end_example
: => (((C2 . 48) . DO) ((E2 . 52) . MI) ((G2 . 55) . SO) ((B3 . 59) . TI)) 

#+begin_example
(car (chord-take 2 (test-chord-builder)))
#+end_example
: => (((C2 . 48) . DO) ((E2 . 52) . MI))

* Upcoming documentation
** additional chord functions inversions

      #+begin_example
   (defun inversion-test ()
     (chord-play (car (triads (chord-builder (scale-range 'C3 'G5 (make-scale 'c4))))))

     (chord-play (chord-over-3 (car (triads (chord-builder (scale-range 'C3 'G5 (make-scale 'c4)))))  (make-scale 'c4)))

     (chord-play (chord-over-5 (car (triads (chord-builder (scale-range 'C3 'G5 (make-scale 'c4))))) (make-scale 'c4)))

     (chord-play (car (triads (chord-builder (scale-range 'C4 'G5 (make-scale 'c4))))))

     )

    (mapcar #'chord-play (take 8 (triads (modes2 (make-scale-from-template 'C2 'B5 (major-scale-template))))))

   (chord-play (chord-invert (car (chords (scale-range 'c3 'G5 (make-scale 'c4)))) (make-scale 'c4)))

   (chord-invert (chord-remove-degree (chord-upper (car (cdr (chords (scale-range 'c3 'G5 (make-scale 'c4)) #'sevenths)))) 5) (make-scale 'c4))
      #+end_example

** with-scale macro

   #+begin_example
     (with-scale (random-major-scale)
       (play-scale *current-scale*))

     (with-scale (random-major-scale)
       (play-tonic-subdominant-dominant  *current-scale*))

     (with-scale (random-major-scale)
       (play-tonic *current-scale*)
       (sleep 0.5)
       (play-subdominant *current-scale*)
       (sleep 0.5)
       (play-dominant *current-scale*)
       (sleep 0.5)
       (play-tonic *current-scale*))

     (with-scale (random-major-scale)
       (solfege-chord '(DO MI SO) *current-scale*))

     (with-scale (random-major-scale)
       (play-tonic-subdominant-dominant *current-scale*))

     (with-scale (random-major-scale)
       (chord-builder *current-scale*))

     (mapcar #'chord-play (triads (chord-builder (build-scale 'C4 (major-scale-template)))))
     (mapcar #'chord-play (subseq (triads (chord-builder (build-scale 'C4 (major-scale-template)))) 16 24))

   #+end_example

** Chord sequencing
   #+begin_example
     (with-scale (build-scale 'C4 (major-scale-template))
     (play-chords (sevenths (chord-sequence '(I IV V I)
					      (scale-range 'C2 'G3 *current-scale*)))))

     (with-scale (build-scale 'C4 (major-scale-template))
       (let* ((chord-list (take-octaves 2 (chord-builder (scale-range 'A2 'C7 *current-scale*))))
	      (chords (chord-roman-numerals (triads chord-list)))
	      (chord-sequence '(I VI- II- V III- VI- II- V I)))

	 (play-chords (mapcar (lambda (rn)
				(find-chord rn chords))
			      chord-sequence))))

     (chord-sequence-play
      (chord-sequence-chords
       (chord-sequence
	'((octave . 3) I (octave . 3) VI- (octave . 3)  II- (octave . 2) V (octave . 3) I)
	(chords (make-scale 'C4) #'sevenths))))

     (chords (make-scale 'C4) #'sevenths)

   #+end_example

** Solfege chords
   #+begin_example
     (with-scale (scale-range 'C4 'G5 (make-scale 'C4))
      (solfege-chord '(Do mi so) *current-scale*)
      (solfege-chord '(re fa la) *current-scale*)
      (solfege-chord '(mi so ti) *current-scale*)
      (arp '(do mi so) *current-scale*)
      (rarp '(do mi so) *current-scale*))

   #+end_example

** Threading function
   #+begin_example
     (-> (make-scale-chords (make-scale 'C2))
	 (scale-chord-filter #'chord-type-filter #'ninths)
	 (scale-chord-filter #'chord-filter #'chord-butfifth)
	 (scale-chord-filter #'chord-filter #'chord-droproot)
	 (chord-seq '(II-
		      (octave . 2)
		      V
		      (octave . 3)
		      I
		      (octave . 3)
		      VI-
		      (octave . 3)
		      II-
		      (octave . 2)
		      V
		      (octave . 3)
		      I
		      I
		      ) 3))

	   #'chord-seq-play)
   #+end_example

** Games
   
*** Solfege trainer

*** Melody Game

*** Bass Game

* Files

** Tests
   #+begin_src sh :exports results :results pp
   cat src/t/tests.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (in-package :ld-music)

   (defun mapnotes (scale fn)
     (mapcar fn (attr2 scale 'notes)))
   (defun maplis (l fn)
     (mapcar fn l))

   (deftest test-midi-notes ()
     (check
       (= 88 (length (midi-notes)))))

   (deftest test-scale-range ()
     (let ((result  (->(make-scale  'c4)
		      (scale-range3 'c4 'c5))))
       (check
	 (= 8 (-> (attr2 result 'notes) (length)))
	 (= 4 (-> (car (attr2 result 'notes)) (attr2 'octave)))
	 (= 5 (attr2 (car (last (attr2 result 'notes))) 'octave)))))

   (deftest test-chromatic-scale-solfege ()
     (check
       (equal '(LA (LI TE) TI DO (DI RA) RE (RI ME) MI FA (FI SE) SO (SI LE) LA (LI TE) TI DO (DI RA) RE (RI ME) MI FA (FI SE) SO (SI LE) LA (LI TE) TI DO (DI RA) RE (RI ME) MI FA (FI SE) SO (SI LE) LA (LI TE) TI DO (DI RA) RE (RI ME) MI FA (FI SE) SO (SI LE) LA (LI TE) TI DO (DI RA) RE (RI ME) MI FA (FI SE) SO (SI LE) LA (LI TE) TI DO (DI RA) RE (RI ME) MI FA (FI SE) SO (SI LE) LA (LI TE) TI DO (DI RA) RE (RI ME) MI FA (FI SE) SO (SI LE) LA (LI TE) TI DO)
	      (-> (make-scale 'c4 (chromatic-scale-template))
		(mapnotes #'note-solfege)))))

   (deftest test-major-scale-solfege ()
     (check
       (equal
	'(LA TI
	  DO RE MI FA SO LA TI
	  DO RE MI FA SO LA TI
	  DO RE MI FA SO LA TI
	  DO RE MI FA SO LA TI
	  DO RE MI FA SO LA TI
	  DO RE MI FA SO LA TI
	  DO RE MI FA SO LA TI DO)
	(-> (make-scale 'c4 (major-scale-template))
	  (mapnotes #'note-solfege)))))

   (deftest test-minor-scale-solfege ()
     (check
       (equal
	'(TE DO RE ME FA SO LE TE
	  DO RE ME FA SO LE TE
	  DO RE ME FA SO LE TE
	  DO RE ME FA SO LE TE
	  DO RE ME FA SO LE TE
	  DO RE ME FA SO LE TE
	  DO RE ME FA SO LE TE DO)
	(-> (make-scale 'c4 (minor-scale-template))
	  (mapnotes #'note-solfege)))))

   (deftest test-find-solfege ()
     (let ((solfege 'do)
	   (l (list (make-note 'c4 72 'do))))
       (check (equal 'do (note-solfege (find-solfege solfege l))))))

   (deftest test-find-solfege2 ()
     (let* ((notes (attr 'notes (make-scale 'c4)))
	    (found-note (find-solfege2 'do notes 5)))

       ;; verify note found in relative octave 
       (check (= 5 (note-relative-octave found-note)))
       ;; verify note found by solfege
       (check (equal 'do (note-solfege found-note)))))

   (deftest test-find-solfege2-chromatic ()
     (let* ((relative-octave 5)
	    (notes (attr 'notes (make-scale 'c4 (chromatic-scale-template))))
	    (found-note (find-solfege2 'di notes relative-octave))
	    (enharmonic-note (find-solfege2 'ra notes relative-octave)))

       ;; verify note found in octave
       (check (= 5 (note-relative-octave found-note)))
       ;; verify note found by solfege
       (check (equal '(di ra) (note-solfege found-note)))
       ;; verify note found by enharmonic solfege
       (check (equal '(di ra) (note-solfege enharmonic-note)))))

   (deftest test-scale-octave-range ()
     ;; verify scale-octave-range returns notes within range
     (check (equal '(4 5)
	      (-> (make-scale 'c4)
		(lambda (scale)
		  (scale-octave-range '4 '5 (attr 'notes scale)))
		(lambda (notes)
		  (find-all-if (lambda (n) (equal 'do (note-solfege n))) notes))
		(maplis #'note-relative-octave)))))

   ;;; TEST NOTE RESOLUTIONS
   (defun test-resolve-note-helper (note notes)
       (-> (resolve-note
	    note
	    notes)
	 (maplis #'note-solfege)))

   (defun checker-fn (a b)
     (eval `(check (equal (quote ,a) (quote ,b)))))

   (defun check-note-resolutions (note->resolutions &optional (scale (make-scale 'c4)))
     (let ((notes (attr 'notes scale)))
       (let ((result t))
	 (dolist (n->r note->resolutions)
	   (unless (checker-fn
		    (second n->r)
		    (test-resolve-note-helper (find-solfege2 (first n->r) notes) notes))
	     (setf result 'f)))
	 result)))

   (deftest test-resolve-notes-major-scale ()
     ;; verify diatonic notes can resolve to DO
     (check-note-resolutions '((do  (do))
			       (re  (re do))
			       (mi  (mi re do))
			       (fa  (fa mi re do))
			       (so  (so la ti do))
			       (la  (la ti do))
			       (ti  (ti do)))))

   (deftest test-resolve--chromatic-scale ()
     ;; verify chromatic notes can resolve to DO
     (check-note-resolutions '(( DO (do))
			       ( DI ((DI RA) DO))
			       ( RA ((DI RA) DO))
			       ( RE (re do) )
			       ( RI ((ri me) re do) )
			       ( ME ((ri me) re do) )
			       ( MI (mi re do) )
			       ( FA (fa mi re do) )
			       ( FI ((FI SE) FA MI RE DO) )
			       ( SO (so la ti do) )
			       ( SI ((SI LE) LA TI DO) )
			       ( LA (la ti do) )
			       ( LI ((LI TE) TI DO) )
			       ( TE ((LI TE) TI DO) )
			       ( TI (ti do)))
			     (make-scale 'c4 (chromatic-scale-template))))
   ;;;; END TEST NOTE RESOLUTION ;;;;


   ;;;; TEST DIATONIC CHORDS ;;;;
   ; seventh chords
   (deftest test-seventh-chords ()
     (let ((chords   (-> (make-scale 'c4)
		       (scale-range3 'c4 'b6) 
		       (make-scale-chords #'sevenths)
		       (scale-chords))))

       ;; verify 7ths are returned
       (check (equal '((DO MI SO TI)
		       (RE FA LA DO)
		       (MI SO TI RE)
		       (FA LA DO MI)
		       (SO TI RE FA)
		       (LA DO MI SO)
		       (TI RE FA LA)
		       (DO MI SO TI))
		     (mapcar #'chord-solfege chords)))))

   ; triads
   (deftest test-triad-chords ()
     (let ((chords   (->
		       (make-scale 'c4)
		       (scale-range3 'c4 'g5) 
		       (make-scale-chords)
		       (scale-chords)
		       (triads))))

       ;; verify triads are returned
       (check (equal '((DO MI SO)
		       (RE FA LA)
		       (MI SO TI)
		       (FA LA DO)
		       (SO TI RE)
		       (LA DO MI)
		       (TI RE FA)
		       (DO MI SO))
		     (mapcar #'chord-solfege chords)))))

   ;;;; TEST DIATONIC CHORDS ;;;;
   (deftest test-chord-sequence ()
     (let* ((chord-data (make-scale-chords (make-scale 'c4)))
	    (sequence '(I II- III- IV V VI- VII I))
	    (chords (chord-sequence2 sequence chord-data)))
       ;; verify default octave
       (check
	 (= 3 (-> chords
		#'chord-sequence-chords
		#'car
		#'chord-notes
		#'car
		#'note-octave))

	 ;; verify chord sequence stored
	 (equal sequence (chord-sequence-romans chords))

       ;; verify solfege realized from roman numeral pattern
	 (equal '((DO MI SO)
		       (RE FA LA)
		       (MI SO TI)
		       (FA LA DO)
		       (SO TI RE)
		       (LA DO MI)
		       (TI RE FA)
		       (DO MI SO))
		     (mapcar #'chord-solfege (triads (chord-sequence-chords chords)))))))



   ;; (deftest test-find-chord ())
   ;; (deftest test-chord-builder ())
   ;; (deftest test-chord-butroot ())
   ;; (deftest test-chord-butfifth ())
   ;; (deftest test-chord-drop-root ())
   ;; (deftest test-chord-invert-upper ())
   ;; (deftest test-make-scale-chords ())
   ;; (deftest test-chord-invert ())
   ;; (deftest test-chord-roman-numerals ())
   ;; (deftest test-scale-chord-filter ())  
   ;; (deftest test-chord-octave-filter ())
   #+end_example


** note
- note representation and functions
   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/note.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun note-name-position (note-name &optional (scale (midi-notes)))
   (defun find-note-in-octave (note notes)
   (defun note-attr (note attr) (cdr (assoc attr note)))
   (defun note-name (note) (note-attr note 'name))
   (defun note-value (note) (note-attr note 'value))
   (defun note-solfege (note) (note-attr note 'solfege))
   (defun note-octave (note) (note-attr note 'octave))
   (defun note-relative-octave (note)
   (defun note-equal-p (x y)
   (defun note-solfege-equalp (note solfege)
   (defun note-idx (note &optional (scale (midi-notes)))
   (defun note-octave-up (note scale)
   (defun note-octave-down (note scale)
   (defun parse-note-octave (note-name)
   (defun find-note (name &optional (scale (midi-notes)))
   (defun make-note (name value solfege)
   #+end_example

** scale
Funcations for making scales and scale templates representation.

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/scale.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun make-scale-template (steps solfege)
   (defun chromatic-scale-template ()
   (defun major-scale-template () (make-scale-template '(w w h w w w h) '(do re mi fa so la ti) ))
   (defun minor-scale-template () (make-scale-template '(w h w w h w w) '(do re me fa so le te)))
   (defun dorian-scale-template () (make-scale-template '(w h w w w h w) '(do re me fa so la ti)))
   (defun phrygian-scale-template () (make-scale-template '(h w w w h w) '(do ra me fa so le te)))
   (defun make-scale (scale-root &optional (template (major-scale-template)))
   (defun make-scale-from-template (p1 p2 scale-template)
   (defun build-scale-up (from-note-pos pattern)
   (defun build-scale-down (from-note-pos pattern)
   (defun assign-solfege (scale scale-template)
   (defun assign-relative-octaves (notes &optional (count 0))
   (defun midi-notes-from-scale (midi-notes original-scale scale)
   (defun midi-notes-from-scale-down-helper (midi-notes original-scale scale)
   (defun build-scale (start-note pattern &optional (notes (midi-notes)))
   (defun scale-notes (scale)
   (defun note-range (n1 n2 notes)
   (defun random-scale (template)
   (defun random-scale2 (template &optional range)
   (defun random-major-scale () (random-scale (major-scale-template)))
   (defun random-major-scale2 () (random-scale2 (major-scale-template)))
   (defun random-chromatic-scale () (random-scale2 (chromatic-scale-template )))
   (defun scale-range (p1 p2 scale-data)
   (defun scale-range3 (scale-data p1 p2)
   (defun with-scale-helper (scale my-fn)
   (defmacro with-scale (scale &body body)
   (defun random-note (scale) (nth (random (length scale)) scale))
   (defun random-notes (y scale) (loop for x from 1 to y collect (random-note scale)))
   (defun solfege-chord (l scale)
   (defun find-solfege (solfege lis)
   (defun find-solfege2 (solfege notes &optional (octave 4))
   (defun solfege->notes (scale solfege-list &optional (octave 4))
   (defun find-prev-do-helper (idx scale)
   (defun find-prev-do (note scale)
   (defun note-to-do (note scale)
   (defun remove-after-do (scale)
   (defun scale-octave-range-helper (o1 o2 notes)
   (defun scale-octave-range (o1 o2 notes)
   (defun scale-octave-range2 (o1 o2 scale)
   (defun resolve-down (note scale)
   (defun resolve-note (note scale)
   ;; (defun major-scales ()
   ;; (defun spell-scale (root)
   #+end_example

** chord
Chord representation and functions

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/chord.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun find-chord2 (octave romand-num chord-data)
   (defun find-chord (octave romand-num chord-list scale)
   (defun make-chord-tone (note degree)
   (defun chord-tone-note (chord-tone) (attr 'note chord-tone))
   (defun chord-degree (chord-tone) (attr 'degree chord-tone))
   (defun chord-notes (chord) (mapcar #'chord-tone-note chord))
   (defun chord-builder (l)
   (defun make-chords (start-note &optional (filter-fn #'triads) (template (major-scale-template)))
   (defun make-scale-chords (scale &optional (filter-fn #'triads) (template (major-scale-template)))
   (defun scale-chords (scale-chord-data) (attr 'chords scale-chord-data))
   (defun chord-sequence-romans (chord-sequence) (mapcar #'car chord-sequence))
   (defun chord-sequence-chords (chord-sequence) (mapcdr chord-sequence))
   (defun chord-solfege (chord)
   (defun chord-root (chord)
   (defun chord-butroot (chord) (chord-remove-degree chord 1))
   (defun chord-butfifth (chord) (chord-remove-degree chord 5))
   (defun chord-drop-root (chord scale) 
   (defun chord-invert-upper (chord)
   (defun chord-tone-degree (chord-tone) (attr 'degree chord-tone))
   (defun chord-remove-degree (chord degree)
   (defun chord-take (n listofchords)
   (defun triads (myl) (chord-take 3 myl))
   (defun sevenths (myl) (chord-take 4 myl))
   (defun ninths (myl) (chord-take 5 myl))
   (defun elevenths (myl) (chord-take 6 myl))
   (defun thirteenths (myl) (chord-take 7 myl))
   (defun chord-triad (chord)
   (defun chord-invert (chord scale)
    (defun chord-over-3 (root-position-chord scale)
   (defun chord-over-5 (root-position-chord scale)
   (defun major-solfege-chords ()
   (defun chord-roman-numerals (chord-list)
   (defun chord-sequence2 (chord-sequence chord-data &optional (octave 4))
   (defun chord-sequence (chord-sequence chords scale &optional (octave 4))
   (defun scale-chord-filter (chord-data fn &rest args)
   (defun octave-filter (octave)
   (defun chord-filter (fn)
   (defun chord-type-filter (fn)
   (defun chord-seq (chord-data seq &optional (octave 4))
   #+end_example

** rhythm
Logic for calculating rhythm durations based on BPM   

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/rhythm.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun rhythm-values (r)
   (defun rhythm->duration-scaled (r bpm)
   (defun beat-length (beat bpm)
   (defun rhythm->seconds (r bpm)
   (defun measure-beats (measure)
   (defun make-measure (&optional (result '()))
   (defun make-measures (n)
   (defun make-rhythmic-notes (notes rhythm-list)
   (defun select-rhythm (notes/rhythms)
   (defun select-note (notes/rhythms)
   (defun rhythmic-notes->midi-messages (rhythmic-notes bpm)
   (defun rhythmic-notes->pm-events (rhythmic-notes bpm &optional (*midi-channel* 0))
   #+end_example

** event
Functions for representing an EVENT (NOTE ON-TIME OFF-TIME VELOCITY)
and for playing an event (via portmidi).

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/event.lisp
   #+end_src

   #+RESULTS:
   : (defun make-event (note on-time off-time velocity)
   : (defun play-event (event)
   : (defun play-events (events)

** util
- Utility functions

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/util.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun fdbug (code)
   (defmacro dbug (code)
   (defun mapcdr (seq) (mapcar #'cdr seq))
   (defun attr2 (alist item) (cdr (assoc item alist)))
   (defun attr (item alist) (cdr (assoc item alist)))
   (defun attr= (value item alist) (setf (cdr (assoc item alist)) value))
   (defun random-element (l) (nth (random (length l)) l))
   (defun take (n l) (subseq l 0 n))
   (defun prepend-tail (lis) (append (last lis) (butlast lis)))
   (defun attrs (item &rest attrlist)
   (defun grow (l1 l2 &optional (idx 0))
   (defun pairup (l1 l2)
   (defun shuffle (sequence &optional (seed (make-random-state t)))
   (defun any? (i l)
   (defun lcontains-p (lx l)
   (defun every-p (lx l)
   (defun find-all-if (pred sequ &rest keyword-args &key &allow-other-keys)
   ;; (defun rotate (scale) (append (cdr scale) (list (car scale))))
   ;; (defun rotate-n (n scale)
   (defun map-idx (s)
   (defun car-eq (item other)
   (defun car-fn (fn args)
   (defun flatten (structure)
   (defun split-seq (pred seq)
   #+end_example

** midi :cleanup:
- Lower-level midi functions

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/midi.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun my-midi-setup ()
   (defun midi-unload ()
   (defun launch-qsynth ()
   (defun kill-qsynth ()
   (defun setup-midi ()
   (defun pm-reload (midi-device-id)
   (defun ensure-midi ()
   (defun pm-terminate ()
   (defun midi-instruments () '(
   (defun midi-note-octave ()
   (defun midi-integers () (loop for x from 0 to 87 collect (+ 21 x)))
   (defun midi-notes ()
   (defun make-message (status data1 data2)
   (defun make-message* (upper lower data1 data2) ;internal
   (defun program-change (program &optional (channel 1) (stream *midi-out3*))
   (defun panic (&optional (channel 1))
   (defun note-on (value &optional (velocity 80) (channel 0) (stream *midi-out3*))
   (defun note-off (value &optional (channel 0) (stream *midi-out3*))
   (defun notes-on (values &optional (velocity 80) (channel 0) (stream *midi-out3*))
   (defun notes-off (values &optional (channel 0) (stream *midi-out3*))
   (defun note-play (note &optional (velocity 80) (channel 0))
   (defun note-stop (note &optional (channel 0))
   (defun note-play-sleep (note)
   (defun write-midi-file-format-0 (outfile midi-notes)
   (defun write-midi-file-format-1 (outfile midi-notes &optional (bpm 60))
   #+end_example

** play
- NEEDS CLEANUP
- functions for playing notes

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/play.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun play-random (scale) (note-play (car (random-note scale))))
   (defun chord-sequence-play (chord-sequence &optional (sleep 1))
   (defun chord-play (chord &optional (sleep 1))
   (defun play-chords (chords)
   (defmacro c (fn &body body) `(,fn (list ,@(mapcar (lambda (x) `',x) body))))
   (defun play-tonic (scale) (note-play (car scale)))
   (defun play-subdominant (scale) (note-play (nth 3 scale)))
   (defun play-dominant (scale) (note-play (nth 4 scale)))
   (defun tonic-subdominant-dominant2 (scale)
   (defun tonic-subdominant-dominant (scale)
   (defun play-tonic-subdominant-dominant (scale)
   (defun smoke-test ()
   (defun play-tonic (scale) (note-play (car scale)))
   (defun play-subdominant (scale) (note-play (nth 3 scale)))
   (defun play-dominant (scale) (note-play (nth 4 scale)))
   (defun play-tonic-subdominant-dominant (scale)
   (defun play-tonic-subdominant-dominant3 (scale)
   #+end_example

** sequencer
- logic for generating/writing midi sequences to file via the MIDI library
- logic for generating midi sequences for portmidi

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/sequencer.lisp
   #+end_src

   #+RESULTS:
   : (defun schedule (time fn &rest args)
   : (defun schedule-note (note &optional (on-time 0) off-time (velocity 80))
   : (defun note->midi-message (note time-on time-off &optional (*midi-channel* 0))
   : (defun midi-timing-track (bpm &optional (*midi-channel* 9))
   : (defun midi-seq-format-1 (rhythmic-notes &optional (bpm 60))
   : (defun midi-seq-format-0 (notes)

** games
- initial logic/functions to support games

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/games.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun make-game (name logic-fn)
   (defun update-game-lst (key item game)
   (defun my-play-game (game)
   (defun find-answers (type game)
   (defun find-unique-answers (type game)
   (defun playing-p (game)
   ;; (defun repeat-answers (type game)
   ;; (defun score (game)
   ;; (defun stop-game (game)
   (defun read-guess () (mapcar #'intern (cl-ppcre:split "\\s+" (read-line))))
   ;; (defun solfege-trainer ()
   (defun run-melody-game (game)
   (defun play-melody-game ()
   (defun prompt-guess (answer game current-scale)
   (defun run-chord-trainer (game)
   (defun play-chord-trainer ()
   (defun prompt-chord-guess (answer game scale)
   (defun set-bass-scale ()
   (defun play-bass-game ()
   (defun run-bass-game (game)
   (defun prompt-bass-guess (answer game scale)
   #+end_example

** random :cleanup:
- NEEDS CLEANUP
- functions for generating random notes / experimenting with note resolutions / cadences

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/random.lisp
   #+end_src

   #+RESULTS:
   : (defun random-notes ()
   : (defun random-chromatic ()
   : (defun sing-do ()
   : (defun random-chromatic2 ()
   : (defun random-chromatic3 ()

** package
- Defines the package and exports

** output.lisp
- Should be taken out of this library.

** examples

   #+begin_src sh :exports results :results pp
   grep "defun\|defmacro" src/examples.lisp
   #+end_src

   #+RESULTS:
   : (defun little-sequence (&optional (division 60))
   : (defun seq (solfege-melody rhythm &optional (scale (scale-range 'c3 'c5 (make-scale 'c3))) (bpm 60))
   : (defun play-seq (&rest args)
   : (defun play-seq2 (events)
   : (defun row-row-row-your-boat ()
   : (defun row-row-row-your-boat2 ()

* Issues
  - setting slot-value 'midi:dd/nn/cc/bb doesn't work out of the box
    because not exported. had to fork cl-midi library and add exports
  - update local cl-portmidi library to get updates and remove
    make-message* fns as make-message now exported
  - work on setting up exports in ASD file
  - should every file be in the same namespace?
  - scale templates can be defined as VARS instead of functions
  - consider using chromatic scale by default in scale logic and deducing other scales from that 
  - +portmidi seems flakey in that sometimes the midi device can't connect after restarting REPL+
    - this seemed to have to do with the connection to the device
      being held open even after the SLIME repl was quit.
    - should now be solved with corrected termination logic, specifically using:
      #+BEGIN_EXAMPLE
      (pm:abort-midi *midi-out*)
      (pm:close-midi *midi-out*)
      #+END_EXAMPLE

* Features
** Completed
- [ ] DSL for generating rhythmic melodies
  - Single octave melody
    #+BEGIN_SRC lisp :package ld-music :exports code
  (solfa
   mi 8 re do re mi mi mi 4
   re 8 re re 4 mi 8 so so 4
   mi 8 re do re mi mi mi 4 re 8 re mi
   re 8 do 1)
    #+END_SRC

    #+RESULTS:
    : NIL

  - Multiple octave melody w/ BPM setting
    #+BEGIN_SRC lisp :package ld-music :exports code
	(solfa
         (:bpm 120)
	 do 4 do do 8 re mi 4
	 mi 8 re mi fa so 2 +
	 do 8 do do - so so so
	 mi mi mi do do do so 4
	 fa 8 mi 4 re 8 do 1)
    #+END_SRC

    #+RESULTS:
    : NIL

- [ ] create chord progressions using roman numerals
  #+BEGIN_SRC lisp :package ld-music :exports both
    (let* ((chord-data (make-scale-chords (make-scale 'c4)))
	   (sequence '((octave . 4)
		       I
		       (octave . 3)
		       VI-
		       (octave . 4)
		       II-
		       (octave . 3)
		       V
		       (octave . 4)
		       I))
	   )
      (triads
       (chord-sequence-chords
	(chord-sequence2 sequence chord-data))))
  #+END_SRC

  #+RESULTS:
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (RELATIVE-OCTAVE . 3) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (RELATIVE-OCTAVE . 4) (OCTAVE . 4)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (RELATIVE-OCTAVE . 3) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (RELATIVE-OCTAVE . 3) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 5)) |

  #+BEGIN_SRC lisp :package ld-music :exports both
      (let* ((chord-data (make-scale-chords (make-scale 'c4)))
	     (sequence '(I II- III- IV V VI- VII I))
	     (chords (chord-sequence2 sequence chord-data)))
	(triads (mapcdr chords)))
  #+END_SRC

  #+RESULTS:
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (RELATIVE-OCTAVE . 4) (OCTAVE . 4)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (RELATIVE-OCTAVE . 4) (OCTAVE . 4)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (RELATIVE-OCTAVE . 4) (OCTAVE . 4)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (RELATIVE-OCTAVE . 5) (OCTAVE . 4)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (RELATIVE-OCTAVE . 4) (OCTAVE . 4)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (RELATIVE-OCTAVE . 5) (OCTAVE . 4)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (RELATIVE-OCTAVE . 4) (OCTAVE . 4)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (RELATIVE-OCTAVE . 5) (OCTAVE . 4)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (RELATIVE-OCTAVE . 5) (OCTAVE . 4)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (RELATIVE-OCTAVE . 4) (OCTAVE . 4)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (RELATIVE-OCTAVE . 5) (OCTAVE . 4)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F4) (VALUE . 77) (SOLFEGE . FA) (RELATIVE-OCTAVE . 5) (OCTAVE . 4)) (DEGREE . 5)) |
  | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (RELATIVE-OCTAVE . 4) (OCTAVE . 3)) (DEGREE . 5)) |

- [X] create melodies using solfege syllables
  
  #+BEGIN_SRC lisp :package ld-music :exports both
    (-> (make-scale 'c4)
	(lambda (scale)
	  (scale-range 'c3 'c5 scale))
	(lambda (scale)
	  (solfege->notes scale '(DO RE MI FA SO LA TI DO))))
  #+END_SRC

  #+RESULTS:
  | (TYPE . NOTE) | (NAME . C3) | (VALUE . 60) | (SOLFEGE . DO) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . D3) | (VALUE . 62) | (SOLFEGE . RE) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . E3) | (VALUE . 64) | (SOLFEGE . MI) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . F3) | (VALUE . 65) | (SOLFEGE . FA) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . G3) | (VALUE . 67) | (SOLFEGE . SO) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . A4) | (VALUE . 69) | (SOLFEGE . LA) | (OCTAVE . 4) |
  | (TYPE . NOTE) | (NAME . B4) | (VALUE . 71) | (SOLFEGE . TI) | (OCTAVE . 4) |
  | (TYPE . NOTE) | (NAME . C3) | (VALUE . 60) | (SOLFEGE . DO) | (OCTAVE . 3) |

- [X] add rhythm to melodic sequences

  #+BEGIN_SRC lisp :package ld-music :exports code
    (-> (make-scale 'c4)
	(lambda (scale)
	  (scale-range 'c3 'c5 scale))
	(lambda (scale)
	  (solfege->notes scale '(DO RE MI FA SO LA TI DO)))
	(lambda (notes)
	  (make-rhythmic-notes notes '(4 4 4 4 2 2 8 8))))
  #+END_SRC

  #+RESULTS:
  : ((((TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) . 4) (((TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) . 4) (((TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) . 4) (((TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) . 4) (((TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) . 2) (((TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) . 2) (((TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) . 8) (((TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) . 8))

- [X] preview sequences in-memory via portmidi

  #+BEGIN_SRC lisp :package ld-music :exports both
    (let* ((bpm 60)
	   (events (-> (make-scale 'c4)
		       (lambda (scale)
			 (solfege->notes (scale-range 'c3 'c5 scale) '(DO RE MI FA SO LA TI DO)))
		       (lambda (notes)
			 (rhythmic-notes->pm-events 
			  (make-rhythmic-notes notes '(4 4 4 4 2 2 8 8)) bpm)))))
      events)
  #+END_SRC

  #+RESULTS:
  | (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) | (ON-TIME . 0)   | (OFF-TIME . 1)   | (VELOCITY . 80) |
  | (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) | (ON-TIME . 1)   | (OFF-TIME . 2)   | (VELOCITY . 80) |
  | (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) | (ON-TIME . 2)   | (OFF-TIME . 3)   | (VELOCITY . 80) |
  | (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) | (ON-TIME . 3)   | (OFF-TIME . 4)   | (VELOCITY . 80) |
  | (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) | (ON-TIME . 4)   | (OFF-TIME . 6)   | (VELOCITY . 80) |
  | (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) | (ON-TIME . 6)   | (OFF-TIME . 8)   | (VELOCITY . 80) |
  | (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) | (ON-TIME . 8)   | (OFF-TIME . 8.5) | (VELOCITY . 80) |
  | (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) | (ON-TIME . 8.5) | (OFF-TIME . 9.0) | (VELOCITY . 80) |

  - Use the #'play-events function

  #+BEGIN_SRC lisp :package ld-music :exports code
  (let* ((bpm 60)
	 (events (-> (make-scale 'c4)
		     (lambda (scale)
		       (solfege->notes (scale-range 'c3 'c5 scale) '(DO RE MI FA SO LA TI DO)))
		     (lambda (notes)
		       (rhythmic-notes->pm-events (make-rhythmic-notes notes '(4 4 4 4 2 2 8 8)) bpm)))))
    (play-events events))
#+END_SRC
- [X] write sequences to MIDI file
  #+BEGIN_SRC  lisp :package ld-music :exports code
    (-> (make-scale 'c4)
	(lambda (scale)
	  (scale-range 'c3 'c5 scale))
	(lambda (scale)
	  (solfege->notes scale '(DO RE MI FA SO LA TI DO)))
	(lambda (notes)
	  (make-rhythmic-notes notes '(4 4 4 4 2 2 8 8)))
	(lambda (rhythmic-notes)
 	  (write-midi-file-format-1 "myoutput.midi" rhythmic-notes)))
  #+END_SRC

  #+RESULTS:
  : NIL

- [X] ear training - random rhythmic melodies following cadence
  #+BEGIN_SRC lisp :package ld-music :exports code
    (play-cadence-melody-sequence (make-random-melody-sequence (make-scale 'c4) 4))

  #+END_SRC

- [X] ear training - single note following cadence
  #+BEGIN_SRC lisp :package ld-music :exports code
    (play-cadence-note-sequence (make-random-note-sequence (make-scale 'c4)))
  #+END_SRC

- [X] ear training - chord progression following cadence
  #+BEGIN_SRC lisp :package ld-music :exports code
    (play-cadence-progression-sequence (make-random-progression-sequence (make-scale 'c4)))
  #+END_SRC

- [X] ear training game - chord game
  #+BEGIN_SRC lisp :package ld-music :exports code
    (play-chord-trainer)
  #+END_SRC

- [X] ear training game - bass melody game
  #+BEGIN_SRC lisp :package ld-music :exports code
    (play-bass-game)
  #+END_SRC

** Upcoming
- [ ] ear training game - melody game
* Ideas for features.
  - represent secondary dominants
  - sequence chords and melodies
  - represent inverted chords
  - add rhythm to chord sequences
  - support midi instruments
  - add pentatonic ear training exercises

* Dependencies
- quicklisp
- *sbcl* dependent
- portmidi - Download it locally
  - https://github.com/chfin/cl-portmidi
  - cd ~/quicklisp/local-projects
  - git clone https://github.com/chfin/cl-portmidi.git

* Setup
#+begin_src lisp
    (ql:quickload "ld-music")
    (in-package :ld-music)
#+end_src

#+RESULTS:
: #<PACKAGE "LD-MUSIC">

* Background
  #+begin_quote
  "This program is ugly, dirty, disgusting, not the way I would write this as a professional. It is written with concrete syntax, meaning I'm going to use lots of cars and cdrs..."
    -- Gerald Jay Sussman (https://youtu.be/aAlR3cezPJg?t=339)
  #+end_quote

This project is my exploration in representing musical information with LISP.

What kind of musical information is there to represent? To start... *Notes, Scales, and Chords.*

- *Notes* - the most basic unit of musical pitch information.
  These are currently represented as integers (MIDI) and symbolically as moveable-do solfege like (DO RE MI) and absolute name "C4" where "C" is the note and "4" is the octave on the keyboard.
- *Scales* - collections of notes based on scale patterns (major, minor, etc)
- *Chords* - collections of notes usually derived from a scale

This program deals only with the notes on a standard 88 key piano as limiting the notes to 88 seems to be practical at this time.

This project depends on the "portmidi" library to output midi to a hardware or software midi device of your choosing.

* High level ideas

  The piano is just a list of 88 notes.  From this fundamental
  structure we can derive all sorts of musical structures.

  I am personally interested in tonal structures such as the major and
  minor scales, diatonic chords derived from major/minor scales, and
  ear training concepts.

  In general, I want to create musical structures using commonly used
  symbols, the same symbols that used in music theory and ear
  training...

  Specifically, I want *solfege* symbols to represent notes, such as:
  
  - Ex.) The major scale in solfege: DO RE MI FA SO LA TI DO
  - Ex.) The nat. minor scale in solfege: DO RE ME FA SO SE LE TE DO
  - Ex.) The asc. chromatic scale: DO DI RE RI MI FA FI SO SI LA LI TI DO
  - Ex.) The desc. chromatic scale: DO TI TE LA LE SO SE FA MI ME RE RA DO

  Beyond solfege, I want to have symbols for referring to diatonic
  chords. In music theory and ear training chords are usually referred
  to by Roman Numerals:

  - Ex.) The most common chord progression: I V VI- IV
  - Ex.) The plagal cadence: I IV I
  - Ex.) The cycle V progression: I IV VII III- VI- III- V I

* MIDI Smoke testing
  
** List the midi devices available on your system:

  #+begin_src lisp  :package ld-music
    (pm:list-devices)
  #+end_src

  #+RESULTS:
  : ((0 . ALSA | Midi Through Port-0 | input: NIL | output: T) (1 . ALSA | Midi Through Port-0 | input: T | output: NIL) (2 . ALSA | Roland Digital Piano MIDI 1 | input: NIL | output: T) (3 . ALSA | Roland Digital Piano MIDI 1 | input: T | output: NIL))


  Find your MIDI device where output: T and copy the Integer.
  For example, my device is (2 . ALSA | Roland Digital Piano MIDI 1 | input: NIL | output: T)
  
** Initialize the midi device and smoke test
   
  #+begin_src lisp :package ld-music
    (pm-initialize 2)
  #+end_src

  #+RESULTS:
  : #.(SB-SYS:INT-SAP #X55AE35D700D0)

You should hear a note play when you run #'smoke-test.

  #+begin_src lisp :package ld-music
    (smoke-test)
  #+end_src

  #+RESULTS:
  : NIL

* DATA FORMATS

- NOTE -- an ALIST grouping TYPE, NAME, VALUE, SOLFEGE, OCTAVE
- SCALE -- an ALIST grouping NOTES and SCALE TEMPLATE
- SCALE TEMPLATE -- a list of scale steps/solfege pairs used to realize scales
  ((W . DO) (W . RE) (H . MI) (W . FA) (W . SO) (W . LA) (H . TI))
- CHORD -- a list of CHORD-TONES
- CHORD-TONE -- an ALIST grouping TYPE, NOTE, DEGREE
- SCALE-CHORD -- an ALIST grouping SCALE, CHORDS, ROMAN-NUMERAL-CHORDS 
- RHYTHMIC-NOTE -- a pairing of NOTE and RHYTHM-VALUE where RHYTHM-VALUE is 1,2,4,8,16
- EVENT -- an ALIST grouping NOTE, ON-TIME, OFF-TIME, VELOCITY

INTERNAL MAKER FUNCTIONS
#+begin_example
  (make-scale-template '(w w h w w w h) '(do re mi fa so la ti do))
  (make-note 'C4 72 'DO) 
  (make-scale-from-template 'C4 'C5 (major-scale-template))
  (make-scale scale-root template)
  (make-scale-chords scale)
  (make-chords start-note)
#+end_example

* Concepts
  
** Notes

A note is technically a frequency like "A 440HZ". But in this program a note is represented as an ALIST with following attributes:

#+begin_src lisp :package ld-music :exports both
(make-note 'A4 69 nil)
#+end_src

#+RESULTS:
: ((TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE) (OCTAVE . 4))

- TYPE -- The type of the object (NOTE)
- NAME -- The absolute name of the note on the keyboard
- VALUE -- The MIDI Value
- OCTAVE -- The keyboard octave
- SOLFEGE : The solfege syllable assigned to the note

*** Note functions

- make-note :: note constructor
- note-name :: note name selector
- note-value :: note midi value selector
- note-solfege :: note solfege syllable selector
- note-octave-up :: the note one octave up
- note-octave-down :: the note one octave down
- note-equal-p :: check for note equality matching *note-value* & *note-name*
- note-name-position :: position of note in scale (by name)
- note-idx :: note position in scale using #'note-equal-p
- parse-note-octave :: Parse octave of the note from the absolute name
- find-note-in-octave :: Find note in a scale sorted by octave relative to the scale (not absolute octaves)
  

** Scale templates

Scale templates are represented by a list of pairs (X,Y) where X is
either W or H and Y is a solfege syllable.

- W :: represents 1 semitone
- H :: represents 2 semitones

This data is used when building scales to assign the correct solfege
syllable to the note. 

#+begin_src lisp :package ld-music :exports both
(major-scale-template)
#+end_src

#+RESULTS:
: ((W . DO) (W . RE) (H . MI) (W . FA) (W . SO) (W . LA) (H . TI))

Making a scale template is done like so:

#+begin_src lisp :package ld-music :exports both
  (make-scale-template '(w w h w w w h)
		       '(do re mi fa so la ti do) )
#+end_src

#+RESULTS:
: ((W . DO) (W . RE) (H . MI) (W . FA) (W . SO) (W . LA) (H . TI))

Other scale templates are defined already:

- Chromatic scale template
  #+begin_src lisp :package ld-music :exports both
  (chromatic-scale-template)
  #+end_src

  #+RESULTS:
  : ((H . DO) (H DI RA) (H . RE) (H RI ME) (H . MI) (H . FA) (H FI SE) (H . SO) (H SI LE) (H . LA) (H LI TE) (H . TI))

- Minor scale template
  #+begin_src lisp :package ld-music :exports both
    (minor-scale-template)
  #+end_src

  #+RESULTS:
  : ((W . DO) (H . RE) (W . ME) (W . FA) (H . SO) (W . LE) (W . TE))

- Dorian scale template
  #+begin_src lisp :package ld-music :exports both
    (make-scale-template '(w h w w w h w) '(do re me fa so la ti do))
  #+end_src

  #+RESULTS:
  : ((W . DO) (H . RE) (W . ME) (W . FA) (W . SO) (H . LA) (W . TI))

*** Scale functions

** Scales

Scales are represented as ALISTS containing NOTES and a TEMPLATE.

** Chord

** Chord Tones

** Scale Chords

* Data and Functions

The initial and most fundamental data we have is a list of MIDI INTEGERS (21..108)

#+begin_src lisp :package ld-music
  (midi-integers)
#+end_src

#+RESULTS:
| 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 |

Then there is the #'midi-note-octave list of absolute note names and octave

 #+begin_src lisp :package ld-music
   (midi-note-octave)
 #+end_src

 #+RESULTS:
 : (A0 |A#0| B0 C0 |C#0| D0 |D#0| E0 F0 |F#0| G0 |G#0| A1 |A#1| B1 C1 |C#1| D1
 :  |D#1| E1 F1 |F#1| G1 |G#1| A2 |A#2| B2 C2 |C#2| D2 |D#2| E2 F2 |F#2| G2 |G#2|
 :  A3 |A#3| B3 C3 |C#3| D3 |D#3| E3 F3 |F#3| G3 |G#3| A4 |A#4| B4 C4 |C#4| D4
 :  |D#4| E4 F4 |F#4| G4 |G#4| A5 |A#5| B5 C5 |C#5| D5 |D#5| E5 F5 |F#5| G5 |G#5|
 :  A6 |A#6| B6 C6 |C#6| D6 |D#6| E6 F6 |F#6| G6 |G#6| A7 |A#7| B7 C7)

 #+begin_src lisp  :package ld-music
   (first (midi-note-octave)) ; A0
   (last (midi-note-octave))  ; (C7)
   (length (midi-note-octave)); 88
 #+end_src

The  #'midi-notes function turns the MIDI integers and absolute note names into the NOTE data structure

#+begin_src lisp  :package ld-music
  (first (midi-notes)); ((TYPE . NOTE) (NAME . A0) (VALUE . 21) (SOLFEGE) (OCTAVE . 0))
  (last (midi-notes)); (((TYPE . NOTE) (NAME . C7) (VALUE . 108) (SOLFEGE) (OCTAVE . 7))) 
  (length (midi-notes)); 88
#+end_src

At this point, we have a basic representation of all notes on the keyboard.
The next step is to build scales.

*Scale templates* are used to realize scales from the patterns they
define. For example, The major scale uses a pattern of "W W H W W W H"
where W is 2 semitones and H is 1 semitone.

The #'make-scale-template function is used to make *scale templates*.

To define the major scale template, set the pattern and the solfege
syllables:

#+begin_src lisp  :package ld-music
  (make-scale-template '(w w h w w w h) '(do re mi fa so la ti do))
#+end_src

#+RESULTS:
: ((W . DO) (W . RE) (H . MI) (W . FA) (W . SO) (W . LA) (H . TI))

To realize the scale, use the *#'make-scale-from-template* function.

The algorithm looks at all notes available and returns only the notes
found according to the scale pattern.

The function signature requires a starting note and end note.

To creates a C major scale from C4 to C5:
#+begin_src lisp  :package ld-music
  (let ((major-scale-template
	  (make-scale-template '(w w h w w w h)
			       '(do re mi fa so la ti do))))
    (make-scale-from-template 'C4 'C5 major-scale-template))
#+end_src

#+RESULTS:
| (TYPE . NOTE) | (NAME . C4) | (VALUE . 72) | (SOLFEGE . DO) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . D4) | (VALUE . 74) | (SOLFEGE . RE) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . E4) | (VALUE . 76) | (SOLFEGE . MI) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . F4) | (VALUE . 77) | (SOLFEGE . FA) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . G4) | (VALUE . 79) | (SOLFEGE . SO) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . A5) | (VALUE . 81) | (SOLFEGE . LA) | (OCTAVE . 5) |
| (TYPE . NOTE) | (NAME . B5) | (VALUE . 83) | (SOLFEGE . TI) | (OCTAVE . 5) |
| (TYPE . NOTE) | (NAME . C5) | (VALUE . 84) | (SOLFEGE . DO) | (OCTAVE . 5) |

Each item in the list is a NOTE -- an ALIST representing SOLFEGENAME,
NOTENAME, MIDI-VALUE, and KEYBOARD OCTAVE.

The functions #'note-name, #'note-value, #'note-solfege are used to
select note data.

** CHORDS
The next logical step would be to build up chords.

The C Major scale notes are C D E F G A B. To make chords, you combine every other note in scale:

The triads in C major are "CEG" "DFA" "EGB" "FAC" "GBD" "ACE" "BDF".

The seventh chords in C major are "CEGA" "DFAG" "EGBD" "FACE" "GBDF" "ACEG" "BDFA".

Use the #'chord-builder function to generate a list of chords.

*#'chord-builder* takes a scale and generates a list of chords up the
the 13th (remember, a chord is just a list of notes)

#+begin_src lisp :package ld-music
  (take 7 (let* ((c-major-scale
	   (make-scale-from-template 'C2 'G4
				     (make-scale-template '(w w h w w w h)
							  '(do re mi fa so la ti do)))))
    (chord-builder c-major-scale)))
#+end_src

#+RESULTS:
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C2) (VALUE . 48) (SOLFEGE . DO) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E2) (VALUE . 52) (SOLFEGE . MI) (OCTAVE . 2)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D2) (VALUE . 50) (SOLFEGE . RE) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E2) (VALUE . 52) (SOLFEGE . MI) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F4) (VALUE . 77) (SOLFEGE . FA) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G4) (VALUE . 79) (SOLFEGE . SO) (OCTAVE . 4)) (DEGREE . 13)) |

*** Triads and Sevenths
The *#'triads* and *#'sevenths* functions take a list of chords and reduce
each chord to a specific number of notes, 3 and 4 respectively.

The *#'chord-take function* takes an integer and list of chords and returns a shortened list.

#+begin_example
  (car (triads (test-chord-builder))) 
#+end_example
: => (((C2 . 48) . DO) ((E2 . 52) . MI) ((G2. 55) . SO))

#+begin_example
  (car (sevenths (test-chord-builder)))
#+end_example
: => (((C2 . 48) . DO) ((E2 . 52) . MI) ((G2 . 55) . SO) ((B3 . 59) . TI)) 

#+begin_example
(car (chord-take 2 (test-chord-builder)))
#+end_example
: => (((C2 . 48) . DO) ((E2 . 52) . MI))

* Upcoming documentation
** additional chord functions inversions

      #+begin_example
   (defun inversion-test ()
     (chord-play (car (triads (chord-builder (scale-range 'C3 'G5 (make-scale 'c4))))))

     (chord-play (chord-over-3 (car (triads (chord-builder (scale-range 'C3 'G5 (make-scale 'c4)))))  (make-scale 'c4)))

     (chord-play (chord-over-5 (car (triads (chord-builder (scale-range 'C3 'G5 (make-scale 'c4))))) (make-scale 'c4)))

     (chord-play (car (triads (chord-builder (scale-range 'C4 'G5 (make-scale 'c4))))))

     )

    (mapcar #'chord-play (take 8 (triads (modes2 (make-scale-from-template 'C2 'B5 (major-scale-template))))))

   (chord-play (chord-invert (car (chords (scale-range 'c3 'G5 (make-scale 'c4)))) (make-scale 'c4)))

   (chord-invert (chord-remove-degree (chord-upper (car (cdr (chords (scale-range 'c3 'G5 (make-scale 'c4)) #'sevenths)))) 5) (make-scale 'c4))
      #+end_example

** with-scale macro

   #+begin_example
     (with-scale (random-major-scale)
       (play-scale *current-scale*))

     (with-scale (random-major-scale)
       (play-tonic-subdominant-dominant  *current-scale*))

     (with-scale (random-major-scale)
       (play-tonic *current-scale*)
       (sleep 0.5)
       (play-subdominant *current-scale*)
       (sleep 0.5)
       (play-dominant *current-scale*)
       (sleep 0.5)
       (play-tonic *current-scale*))

     (with-scale (random-major-scale)
       (solfege-chord '(DO MI SO) *current-scale*))

     (with-scale (random-major-scale)
       (play-tonic-subdominant-dominant *current-scale*))

     (with-scale (random-major-scale)
       (chord-builder *current-scale*))

     (mapcar #'chord-play (triads (chord-builder (build-scale 'C4 (major-scale-template)))))
     (mapcar #'chord-play (subseq (triads (chord-builder (build-scale 'C4 (major-scale-template)))) 16 24))

   #+end_example

** Chord sequencing
   #+begin_example
     (with-scale (build-scale 'C4 (major-scale-template))
       (play-chords (sevenths (chord-sequence '(I IV V I)
					      (scale-range 'C2 'G3 *current-scale*)))))

     (with-scale (build-scale 'C4 (major-scale-template))
       (let* ((chord-list (take-octaves 2 (chord-builder (scale-range 'A2 'C7 *current-scale*))))
	      (chords (chord-roman-numerals (triads chord-list)))
	      (chord-sequence '(I VI- II- V III- VI- II- V I)))

	 (play-chords (mapcar (lambda (rn)
				(find-chord rn chords))
			      chord-sequence))))

     (chord-sequence-play
      (chord-sequence-chords
       (chord-sequence
	'((octave . 3) I (octave . 3) VI- (octave . 3)  II- (octave . 2) V (octave . 3) I)
	(chords (make-scale 'C4) #'sevenths))))
   
     (chords (make-scale 'C4) #'sevenths)

   #+end_example

** Solfege chords
   #+begin_example
     (with-scale (scale-range 'C4 'G5 (make-scale 'C4))
      (solfege-chord '(Do mi so) *current-scale*)
      (solfege-chord '(re fa la) *current-scale*)
      (solfege-chord '(mi so ti) *current-scale*)
      (arp '(do mi so) *current-scale*)
      (rarp '(do mi so) *current-scale*))

   #+end_example

** Threading function
   #+begin_example
     (-> (make-scale-chords (make-scale 'C2))
	 (scale-chord-filter #'chord-type-filter #'ninths)
	 (scale-chord-filter #'chord-filter #'chord-butfifth)
	 (scale-chord-filter #'chord-filter #'chord-droproot)
	 (chord-seq '(II-
		      (octave . 2)
		      V
		      (octave . 3)
		      I
		      (octave . 3)
		      VI-
		      (octave . 3)
		      II-
		      (octave . 2)
		      V
		      (octave . 3)
		      I
		      I
		      ) 3))

	   #'chord-seq-play)
   #+end_example

** Games
   
*** Solfege trainer

*** Melody Game

*** Bass Game

* Files
** package
- Defines the package and exports

** random :cleanup:
functions for generating random notes

- (defun find-prev-do-helper (idx scale)
- (defun find-prev-do (note scale)
- (defun resolve-down (note scale)
- (defun resolve-note (note scale)
- (defun note-to-do (note scale)
- (defun remove-after-do (scale)
- (defun random-notes ()
- (defun random-chromatic ()
- (defun scale-octave-range-helper (o1 o2 scale)
- (defun scale-octave-range (o1 o2 notes)
- (defun play-tonic-subdominant-dominant2 (scale)
- (defun play-tonic-subdominant-dominant3 (scale)
- (defun sing-do ()
- (defun random-chromatic2 ()
- (defun random-chromatic3 ()
- (defun notes->midi ()

** output.lisp
- Should be taken out of this library.

** util
- Utility functions

- (defun mapcdr (seq) (mapcar #'cdr seq))
- (defun attr (item alist) (cdr (assoc item alist)))
- (defun attr= (value item alist) (setf (cdr (assoc item alist)) value))
- (defun random-element (l) (nth (random (length l)) l))
- (defun take (n l) (subseq l 0 n))
- (defun prepend-tail (lis) (append (last lis) (butlast lis)))
- (defun attrs (item &rest attrlist)
- (defun -> (item &rest fns)
- (defun grow (l1 l2 &optional (idx 0))
- (defun pairup (l1 l2)
- (defun shuffle (sequence &optional (seed (make-random-state t)))
- (defun any? (i l)
- (defun lcontains-p (lx l)
- (defun every-p (lx l)
- (defun find-all-if (pred sequ &rest keyword-args &key &allow-other-keys)
- (defun map-idx (s)

** midi :cleanup:
- Lower-level midi functions

- (defun pm-reload (midi-device-id)
- (defun ensure-midi ()
- (defun pm-terminate ()
- (defun pm-initialize (midi-device-id)
- (defun midi-instruments () '(
- (defun midi-note-octave ()
- (defun midi-integers () (loop for x from 0 to 87 collect (+ 21 x)))
- (defun midi-notes ()
- (defun make-message (status data1 data2)
- (defun make-message* (upper lower data1 data2) ;internal
- (defun program-change (program &optional (channel 1) (stream *midi-out3*))
- (defun panic (&optional (channel 1))
- (defun note-on (value &optional (velocity 80) (channel 0) (stream *midi-out3*))
- (defun note-off (value &optional (channel 0) (stream *midi-out3*))
- (defun notes-on (values &optional (velocity 80) (channel 0) (stream *midi-out3*))
- (defun notes-off (values &optional (channel 0) (stream *midi-out3*))
- (defun note-play (note &optional (velocity 80) (channel 1))
- (defun note-stop (note &optional (channel 1))
- (defun note-play-sleep (note)
- (defun write-midi-file-format-0 (outfile midi-notes)
- (defun write-midi-file-format-1 (outfile midi-notes &optional (division 60))

** chord
- chord representation and functions

- (defun find-chord (octave romand-num chord-list scale)
- (defun make-chord-tone (note degree)
- (defun chord-tone-note (chord-tone)(attr 'note chord-tone))
- (defun chord-degree (chord-tone) (attr 'degree chord-tone))
- (defun chord-notes (chord) (mapcar #'chord-tone-note chord))
- (defun chord-builder (l)
- (defun make-chords (start-note &optional (filter-fn #'triads) (template (major-scale-template)))
- (defun make-scale-chords (scale)
- (defun scale-chords (scale-chord-data) (attr 'chords scale-chord-data))
- (defun chord-sequence-chords (chord-sequence) (mapcdr chord-sequence))
- (defun chord-root (chord)
- (defun chord-sequence-play (chord-sequence &optional (sleep 1))
- (defun chord-butroot (chord) (chord-remove-degree chord 1))
- (defun chord-butfifth (chord) (chord-remove-degree chord 5))
- (defun chord-drop-root (chord) 
- (defun chord-invert-upper (chord)
- (defun chord-tone-degree (chord-tone) (attr 'degree chord-tone))
- (defun chord-remove-degree (chord degree)
- (defun chord-take (n listofchords)
- (defun triads (myl) (chord-take 3 myl))
- (defun sevenths (myl) (chord-take 4 myl))
- (defun ninths (myl) (chord-take 5 myl))
- (defun elevenths (myl) (chord-take 6 myl))
- (defun thirteenths (myl) (chord-take 7 myl))
- (defun chord-invert (chord scale)
- (defun chord-over-3 (root-position-chord scale)
- (defun chord-over-5 (root-position-chord scale)
- (defun major-solfege-chords ()
- (defun chord-roman-numerals (chord-list)
- (defun chord-sequence (chord-sequence chords scale &optional (octave 4))
- (defun scale-chord-filter (fn &rest args)
- (defun rebuild-chords ()
- (defun octave-filter (octave)
- (defun chord-filter (fn)
- (defun chord-type-filter (fn)
- (defun chord-seq (seq &optional (octave 4))


** note
- note representation and functions

- (defun note-name-position (note-name &optional (scale (midi-notes)))
- (defun find-note-in-octave (note scale)
- (defun note-attr (note attr) (cdr (assoc attr note)))
- (defun note-name (note) (note-attr note 'name))
- (defun note-value (note) (note-attr note 'value))
- (defun note-solfege (note) (note-attr note 'solfege))
- (defun note-equal-p (x y)
- (defun note-idx (note &optional (scale (midi-notes)))
- (defun note-octave-up (note scale)
- (defun note-octave-down (note scale)
- (defun parse-note-octave (note-name)
- (defun find-note (name &optional (scale (midi-notes)))
- (defun make-note (name value solfege)

** scale
- note representation and functions

- (defun make-scale-template (steps solfege)
- (defun chromatic-scale-template ()
- (defun major-scale-template () (make-scale-template '(w w h w w w h) '(do re mi fa so la ti) ))
- (defun minor-scale-template () (make-scale-template '(w h w w h w w) '(do re me fa so le te)))
- (defun dorian-scale-template () (make-scale-template '(w h w w w h w) '(do re me fa so la ti)))
- (defun phrygian-scale-template () (make-scale-template '(h w w w h w) '(do ra me fa so le te)))
- (defun scale-range (n1 n2 scale)
- (defun make-scale-from-template (p1 p2 scale-template)
- (defun build-scale-up (from-note-pos pattern)
- (defun build-scale-down (from-note-pos pattern)
- (defun assign-solfege (scale scale-template)
- (defun build-scale (start-note pattern &optional (notes (midi-notes)))
- (defun random-scale (template)
- (defun random-scale2 (template)
- (defun random-major-scale () (random-scale (major-scale-template)))
- (defun random-major-scale2 () (random-scale2 (major-scale-template)))
- (defun random-chromatic-scale () (random-scale2 (chromatic-scale-template )))
- (defun scale-notes (scale)
- (defun make-scale (scale-root &optional (template (major-scale-template)))
- (defun scale-range2 (p1 p2 scale-data)
- (defun scale-octaves (scale &optional (count 0))
- (defun midi-notes-from-scale (midi-notes original-scale scale)
- (defun midi-notes-from-scale-down-helper (midi-notes original-scale scale)
- (defun with-scale-helper (scale my-fn)
- (defun random-note (scale) (nth (random (length scale)) scale))
- (defun random-notes (y scale) (loop for x from 1 to y collect (random-note scale)))
- (defun solfege-chord (l scale)
- (defun find-solfege (solfege lis)
- (defun solfege->notes (scale solfege-list)

** play
- functions for playing notes

- (defun play-random (scale) (note-play (car (random-note scale))))
- (defun chord-play (chord &optional (sleep 1))
- (defun chord-seq-play (chord-seq)
- (defun play-chords (chords)
- (defun arp (l scale)
- (defun rarp (l scale)
- (defun play-tonic (scale) (note-play (car scale)))
- (defun play-subdominant (scale) (note-play (nth 3 scale)))
- (defun play-dominant (scale) (note-play (nth 4 scale)))
- (defun play-tonic-subdominant-dominant (scale)
- (defun smoke-test ()

** games
- logic/functions to support games

** sequencer
- logic for generating/writing midi sequences to file
- logic for generating midi sequences for portmidi

- (defun schedule (time fn &rest args)
- (defun schedule-note (note &optional (on-time 0) off-time (velocity 80))
- (defun note->midi-message (note time-on time-off &optional (*midi-channel* 0))
- (defun midi-timing-track (bpm &optional (*midi-channel* 9))
- (defun midi-seq-format-1 (rhythmic-notes &optional (bpm 60))
- (defun midi-seq-format-0 (notes)
- (defun rhythmic-notes->midi-messages (notes/rhythms bpm)
- (defun rhythmic-notes->pm-events (notes/rhythms bpm &optional (*midi-channel* 0))

** rhythm
- logic for calculating rhythm durations based on BPM   

- (defun make-rhythmic-notes (notes rhythm-list)
- (defun rhythm->duration-scaled (r bpm)
- (defun beat-length (beat bpm)
- (defun rhythm->seconds (r bpm)

** event
- (defun make-event (note on-time off-time velocity)
- (defun play-event (event)
- (defun play-events (events)

* Issues
  - setting slot-value 'midi:dd/nn/cc/bb doesn't work out of the box
    because not exported. had to fork cl-midi library and add exports
  - update local cl-portmidi library to get updates and remove
    make-message* fns as make-message now exported
  - work on setting up exports in ASD file
  - should every file be in the same namespace?

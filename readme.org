* Dependencies
** quicklisp
- https://www.quicklisp.org/beta/#installation
** *sbcl* dependent
I am using SBCL and the #'schedule fn (in sequencer.lisp) spawns a
thread. I believe the thread functionality is SBCL dependent.

** portmidi - Download it locally
This depends on the *portmidi* library to play midi in-memory to a
hardware or software midi device of your choosing.

  - https://github.com/chfin/cl-portmidi
  - cd ~/quicklisp/local-projects
  - git clone https://github.com/chfin/cl-portmidi.git

** midi library - Download it locally
The MIDI library provides the ability to read/write midi files.

  - cd ~/quicklisp/local-projects
  - git clone https://github.com/ldenman/midi
    
** SLIME/SWANK :optional:investigate:
- I seem to need this file to get SLIME/SWANK to work with portmidi:

#+begin_example
(setf SWANK:*COMMUNICATION-STYLE* :FD-HANDLER)
#+end_example

* Setup
#+begin_src lisp
    (ql:quickload "ld-music")
    (in-package :ld-music)
#+end_src

#+RESULTS:
: #<PACKAGE "LD-MUSIC">

* Background
  #+begin_quote
  "This program is ugly, dirty, disgusting, not the way I would write this as a professional. It is written with concrete syntax, meaning I'm going to use lots of cars and cdrs..."
    -- Gerald Jay Sussman (https://youtu.be/aAlR3cezPJg?t=339)
  #+end_quote

This project is my exploration in representing musical information with LISP.

What kind of musical information is there to represent? To start... *Notes, Scales, and Chords.*

- *Notes* - the most basic unit of musical pitch information.
  These are currently represented as integers (MIDI) and symbolically as moveable-do solfege like (DO RE MI) and absolute name "C4" where "C" is the note and "4" is the octave on the keyboard.
- *Scales* - collections of notes based on scale patterns (major, minor, etc)
- *Chords* - collections of notes usually derived from a scale

This program deals only with the notes on a standard 88 key piano as limiting the notes to 88 seems to be practical at this time.



** High level ideas

  The piano is a _list_ of 88 notes.  From this structure we can
  derive all sorts of musical structures.

  I'm interested in tonal structures... the major and minor scales,
  diatonic chords derived from those scales, and ear training
  concepts.

  In general, I want to create musical structure with commonly used
  symbols, the same ones used in music theory and ear training
  classes...

  Specifically, I want *solfege* symbols to reference scale and chord tones, such as:
  
  - Ex.) The major scale in solfege: DO RE MI FA SO LA TI DO
  - Ex.) The nat. minor scale in solfege: DO RE ME FA SO SE LE TE DO
  - Ex.) The asc. chromatic scale: DO DI RE RI MI FA FI SO SI LA LI TI DO
  - Ex.) The desc. chromatic scale: DO TI TE LA LE SO SE FA MI ME RE RA DO

  I also want symbols for referring to diatonic chords. In music
  theory and ear training chords are usually referred to by Roman
  Numerals:

  - Ex.) The most common chord progression: I V VI- IV
  - Ex.) The plagal cadence: I IV I
  - Ex.) The cycle V progression: I IV VII III- VI- III- V I

* MIDI Smoke testing
** List the midi devices available on your system:

  #+begin_src lisp  :package ld-music
    (pm:list-devices)
  #+end_src

  #+RESULTS:
  : ((0 . ALSA | Midi Through Port-0 | input: NIL | output: T) (1 . ALSA | Midi Through Port-0 | input: T | output: NIL) (2 . ALSA | Roland Digital Piano MIDI 1 | input: NIL | output: T) (3 . ALSA | Roland Digital Piano MIDI 1 | input: T | output: NIL))


  Find your MIDI device where output: T and copy the Integer.
  For example, my device is (2 . ALSA | Roland Digital Piano MIDI 1 | input: NIL | output: T)
  
** Initialize the midi device and smoke test
   
  #+begin_src lisp :package ld-music
    (pm-initialize 2)
  #+end_src

  #+RESULTS:
  : #.(SB-SYS:INT-SAP #X55AE35D700D0)

You should hear a note play when you run #'smoke-test.

  #+begin_src lisp :package ld-music
    (smoke-test)
  #+end_src

  #+RESULTS:
  : NIL

* DATA FORMATS

- NOTE :: an ALIST grouping TYPE, NAME, VALUE, SOLFEGE, OCTAVE
- SCALE :: an ALIST grouping NOTES and SCALE TEMPLATE
- SCALE TEMPLATE :: a list of scale steps/solfege pairs used to realize scales
- CHORD :: a list of CHORD-TONES
- CHORD-TONE :: an ALIST grouping TYPE, NOTE, DEGREE
- SCALE-CHORD :: an ALIST grouping SCALE, CHORDS, ROMAN-NUMERAL-CHORDS 
- RHYTHMIC-NOTE :: a pairing of NOTE and RHYTHM-VALUE where RHYTHM-VALUE is 1,2,4,8,16
- EVENT :: an ALIST grouping NOTE, ON-TIME, OFF-TIME, VELOCITY

* Concepts
  
** Notes

A note is technically a frequency like "A 440HZ". But in this program a note is represented as an ALIST with following attributes:

- TYPE :: The type of the object (NOTE)
- NAME :: The absolute name of the note on the keyboard
- VALUE :: The MIDI Value
- OCTAVE :: The keyboard octave
- SOLFEGE :: The solfege syllable assigned to the note

#+begin_src lisp :package ld-music :exports both
(make-note 'A4 69 nil)
#+end_src

#+RESULTS:
: ((TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE) (OCTAVE . 4))

** Scale templates

Scale templates are represented by a list of pairs (X . Y) where *X* is
either W or H, representing 1 semitone or 2 semitones, respectivley and *Y* is a solfege syllable (ie. *DO*).
*Y* may also be a LIST of enharmonic solfege syllables such as '(*DI RA*) or '(*FI SE*).

- W :: represents 1 semitone
- H :: represents 2 semitones

This scale template is used to "realize" scales, stepping and
collecting notes according to the semitone pattern (ie W W H W W W H)
and assigning a solfege syllable (or list of enharmonic solfa) to the
note.

*** Usage
Making a scale template is done like so:

#+begin_src lisp :package ld-music :exports both
  (make-scale-template '(w w h w w w h)
		       '(do re mi fa so la ti do) )
#+end_src

#+RESULTS:
: ((W . DO) (W . RE) (H . MI) (W . FA) (W . SO) (W . LA) (H . TI))

Some scale templates are defined as functions:

- Chromatic scale template uses enharmonic solfa:
  #+begin_src lisp :package ld-music :exports both
  (chromatic-scale-template)
  #+end_src

  #+RESULTS:
  : ((H . DO) (H DI RA) (H . RE) (H RI ME) (H . MI) (H . FA) (H FI SE) (H . SO) (H SI LE) (H . LA) (H LI TE) (H . TI))

- Minor scale template
  #+begin_src lisp :package ld-music :exports both
    (minor-scale-template)
  #+end_src

  #+RESULTS:
  : ((W . DO) (H . RE) (W . ME) (W . FA) (H . SO) (W . LE) (W . TE))

- Dorian scale template
  #+begin_src lisp :package ld-music :exports both
    (dorian-scale-template)
  #+end_src

  #+RESULTS:
  : ((W . DO) (H . RE) (W . ME) (W . FA) (W . SO) (H . LA) (W . TI))

** Scales

Scales are represented as ALISTS containing LIST of NOTES and a SCALE-TEMPLATE.

- NOTES :: A LIST of NOTES
- TEMPLATE :: The scale template used to realize the notes; defaults to the *major-scale-template*

*** Usage

**** #'make-scale
The #'make-scale function is used to create scales from a template. The default scale template is the major scale. 

  #+begin_src lisp :package ld-music :exports code
  (make-scale 'c4)
  #+end_src

  #+RESULTS:
  | NOTES    | ((TYPE . NOTE) (NAME . A0) (VALUE . 21) (SOLFEGE . LA) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . B0) (VALUE . 23) (SOLFEGE . TI) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . C0) (VALUE . 24) (SOLFEGE . DO) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . D0) (VALUE . 26) (SOLFEGE . RE) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . E0) (VALUE . 28) (SOLFEGE . MI) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . F0) (VALUE . 29) (SOLFEGE . FA) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . G0) (VALUE . 31) (SOLFEGE . SO) (OCTAVE . 0)) | ((TYPE . NOTE) (NAME . A1) (VALUE . 33) (SOLFEGE . LA) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . B1) (VALUE . 35) (SOLFEGE . TI) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . C1) (VALUE . 36) (SOLFEGE . DO) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . D1) (VALUE . 38) (SOLFEGE . RE) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . E1) (VALUE . 40) (SOLFEGE . MI) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . F1) (VALUE . 41) (SOLFEGE . FA) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . G1) (VALUE . 43) (SOLFEGE . SO) (OCTAVE . 1)) | ((TYPE . NOTE) (NAME . A2) (VALUE . 45) (SOLFEGE . LA) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . B2) (VALUE . 47) (SOLFEGE . TI) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . C2) (VALUE . 48) (SOLFEGE . DO) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . D2) (VALUE . 50) (SOLFEGE . RE) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . E2) (VALUE . 52) (SOLFEGE . MI) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) | ((TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) | ((TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . F4) (VALUE . 77) (SOLFEGE . FA) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . G4) (VALUE . 79) (SOLFEGE . SO) (OCTAVE . 4)) | ((TYPE . NOTE) (NAME . A5) (VALUE . 81) (SOLFEGE . LA) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . B5) (VALUE . 83) (SOLFEGE . TI) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . C5) (VALUE . 84) (SOLFEGE . DO) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . D5) (VALUE . 86) (SOLFEGE . RE) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . E5) (VALUE . 88) (SOLFEGE . MI) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . F5) (VALUE . 89) (SOLFEGE . FA) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . G5) (VALUE . 91) (SOLFEGE . SO) (OCTAVE . 5)) | ((TYPE . NOTE) (NAME . A6) (VALUE . 93) (SOLFEGE . LA) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . B6) (VALUE . 95) (SOLFEGE . TI) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . C6) (VALUE . 96) (SOLFEGE . DO) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . D6) (VALUE . 98) (SOLFEGE . RE) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . E6) (VALUE . 100) (SOLFEGE . MI) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . F6) (VALUE . 101) (SOLFEGE . FA) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . G6) (VALUE . 103) (SOLFEGE . SO) (OCTAVE . 6)) | ((TYPE . NOTE) (NAME . A7) (VALUE . 105) (SOLFEGE . LA) (OCTAVE . 7)) | ((TYPE . NOTE) (NAME . B7) (VALUE . 107) (SOLFEGE . TI) (OCTAVE . 7)) | ((TYPE . NOTE) (NAME . C7) (VALUE . 108) (SOLFEGE . DO) (OCTAVE . 7)) |
  | TEMPLATE | (W . DO)                                                             | (W . RE)                                                             | (H . MI)                                                             | (W . FA)                                                             | (W . SO)                                                             | (W . LA)                                                             | (H . TI)                                                             |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                      |                                                                       |                                                                       |                                                                       |                                                                       |                                                                       |                                                                       |
  #+begin_src lisp :package ld-music :exports code
  (make-scale 'c4 (chromatic-scale-template))
  #+end_src

  #+RESULTS:
  #+begin_example
  ((NOTES ((TYPE . NOTE) (NAME . A0) (VALUE . 21) (SOLFEGE . LA) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |A#0|) (VALUE . 22) (SOLFEGE LI TE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . B0) (VALUE . 23) (SOLFEGE . TI) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . C0) (VALUE . 24) (SOLFEGE . DO) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |C#0|) (VALUE . 25) (SOLFEGE DI RA) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . D0) (VALUE . 26) (SOLFEGE . RE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |D#0|) (VALUE . 27) (SOLFEGE RI ME) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . E0) (VALUE . 28) (SOLFEGE . MI) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . F0) (VALUE . 29) (SOLFEGE . FA) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |F#0|) (VALUE . 30) (SOLFEGE FI SE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . G0) (VALUE . 31) (SOLFEGE . SO) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |G#0|) (VALUE . 32) (SOLFEGE SI LE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . A1) (VALUE . 33) (SOLFEGE . LA) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |A#1|) (VALUE . 34) (SOLFEGE LI TE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . B1) (VALUE . 35) (SOLFEGE . TI) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . C1) (VALUE . 36) (SOLFEGE . DO) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |C#1|) (VALUE . 37) (SOLFEGE DI RA) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . D1) (VALUE . 38) (SOLFEGE . RE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |D#1|) (VALUE . 39) (SOLFEGE RI ME) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . E1) (VALUE . 40) (SOLFEGE . MI) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . F1) (VALUE . 41) (SOLFEGE . FA) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |F#1|) (VALUE . 42) (SOLFEGE FI SE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . G1) (VALUE . 43) (SOLFEGE . SO) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |G#1|) (VALUE . 44) (SOLFEGE SI LE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . A2) (VALUE . 45) (SOLFEGE . LA) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |A#2|) (VALUE . 46) (SOLFEGE LI TE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . B2) (VALUE . 47) (SOLFEGE . TI) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . C2) (VALUE . 48) (SOLFEGE . DO) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |C#2|) (VALUE . 49) (SOLFEGE DI RA) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . D2) (VALUE . 50) (SOLFEGE . RE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |D#2|) (VALUE . 51) (SOLFEGE RI ME) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . E2) (VALUE . 52) (SOLFEGE . MI) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |F#2|) (VALUE . 54) (SOLFEGE FI SE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |G#2|) (VALUE . 56) (SOLFEGE SI LE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |A#3|) (VALUE . 58) (SOLFEGE LI TE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |C#3|) (VALUE . 61) (SOLFEGE DI RA) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |D#3|) (VALUE . 63) (SOLFEGE RI ME) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |F#3|) (VALUE . 66) (SOLFEGE FI SE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |G#3|) (VALUE . 68) (SOLFEGE SI LE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |A#4|) (VALUE . 70) (SOLFEGE LI TE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |C#4|) (VALUE . 73) (SOLFEGE DI RA) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |D#4|) (VALUE . 75) (SOLFEGE RI ME) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . F4) (VALUE . 77) (SOLFEGE . FA) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |F#4|) (VALUE . 78) (SOLFEGE FI SE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . G4) (VALUE . 79) (SOLFEGE . SO) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |G#4|) (VALUE . 80) (SOLFEGE SI LE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . A5) (VALUE . 81) (SOLFEGE . LA) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |A#5|) (VALUE . 82) (SOLFEGE LI TE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . B5) (VALUE . 83) (SOLFEGE . TI) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . C5) (VALUE . 84) (SOLFEGE . DO) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |C#5|) (VALUE . 85) (SOLFEGE DI RA) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . D5) (VALUE . 86) (SOLFEGE . RE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |D#5|) (VALUE . 87) (SOLFEGE RI ME) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . E5) (VALUE . 88) (SOLFEGE . MI) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . F5) (VALUE . 89) (SOLFEGE . FA) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |F#5|) (VALUE . 90) (SOLFEGE FI SE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . G5) (VALUE . 91) (SOLFEGE . SO) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |G#5|) (VALUE . 92) (SOLFEGE SI LE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . A6) (VALUE . 93) (SOLFEGE . LA) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |A#6|) (VALUE . 94) (SOLFEGE LI TE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . B6) (VALUE . 95) (SOLFEGE . TI) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . C6) (VALUE . 96) (SOLFEGE . DO) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |C#6|) (VALUE . 97) (SOLFEGE DI RA) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . D6) (VALUE . 98) (SOLFEGE . RE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |D#6|) (VALUE . 99) (SOLFEGE RI ME) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . E6) (VALUE . 100) (SOLFEGE . MI) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . F6) (VALUE . 101) (SOLFEGE . FA) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |F#6|) (VALUE . 102) (SOLFEGE FI SE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . G6) (VALUE . 103) (SOLFEGE . SO) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |G#6|) (VALUE . 104) (SOLFEGE SI LE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . A7) (VALUE . 105) (SOLFEGE . LA) (OCTAVE . 7))
    ((TYPE . NOTE) (NAME . |A#7|) (VALUE . 106) (SOLFEGE LI TE) (OCTAVE . 7))
    ((TYPE . NOTE) (NAME . B7) (VALUE . 107) (SOLFEGE . TI) (OCTAVE . 7))
    ((TYPE . NOTE) (NAME . C7) (VALUE . 108) (SOLFEGE . DO) (OCTAVE . 7)))
   (TEMPLATE (H . DO) (H DI RA) (H . RE) (H RI ME) (H . MI) (H . FA) (H FI SE)
    (H . SO) (H SI LE) (H . LA) (H LI TE) (H . TI)))
  #+end_example

  #+begin_src lisp :package ld-music :exports code
  (make-scale 'c4 (minor-scale-template))
  #+end_src

  #+RESULTS:
  #+begin_example
  ((NOTES ((TYPE . NOTE) (NAME . |A#0|) (VALUE . 22) (SOLFEGE . TE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . C0) (VALUE . 24) (SOLFEGE . DO) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . D0) (VALUE . 26) (SOLFEGE . RE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |D#0|) (VALUE . 27) (SOLFEGE . ME) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . F0) (VALUE . 29) (SOLFEGE . FA) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . G0) (VALUE . 31) (SOLFEGE . SO) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |G#0|) (VALUE . 32) (SOLFEGE . LE) (OCTAVE . 0))
    ((TYPE . NOTE) (NAME . |A#1|) (VALUE . 34) (SOLFEGE . TE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . C1) (VALUE . 36) (SOLFEGE . DO) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . D1) (VALUE . 38) (SOLFEGE . RE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |D#1|) (VALUE . 39) (SOLFEGE . ME) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . F1) (VALUE . 41) (SOLFEGE . FA) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . G1) (VALUE . 43) (SOLFEGE . SO) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |G#1|) (VALUE . 44) (SOLFEGE . LE) (OCTAVE . 1))
    ((TYPE . NOTE) (NAME . |A#2|) (VALUE . 46) (SOLFEGE . TE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . C2) (VALUE . 48) (SOLFEGE . DO) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . D2) (VALUE . 50) (SOLFEGE . RE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |D#2|) (VALUE . 51) (SOLFEGE . ME) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |G#2|) (VALUE . 56) (SOLFEGE . LE) (OCTAVE . 2))
    ((TYPE . NOTE) (NAME . |A#3|) (VALUE . 58) (SOLFEGE . TE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |D#3|) (VALUE . 63) (SOLFEGE . ME) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |G#3|) (VALUE . 68) (SOLFEGE . LE) (OCTAVE . 3))
    ((TYPE . NOTE) (NAME . |A#4|) (VALUE . 70) (SOLFEGE . TE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |D#4|) (VALUE . 75) (SOLFEGE . ME) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . F4) (VALUE . 77) (SOLFEGE . FA) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . G4) (VALUE . 79) (SOLFEGE . SO) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |G#4|) (VALUE . 80) (SOLFEGE . LE) (OCTAVE . 4))
    ((TYPE . NOTE) (NAME . |A#5|) (VALUE . 82) (SOLFEGE . TE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . C5) (VALUE . 84) (SOLFEGE . DO) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . D5) (VALUE . 86) (SOLFEGE . RE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |D#5|) (VALUE . 87) (SOLFEGE . ME) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . F5) (VALUE . 89) (SOLFEGE . FA) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . G5) (VALUE . 91) (SOLFEGE . SO) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |G#5|) (VALUE . 92) (SOLFEGE . LE) (OCTAVE . 5))
    ((TYPE . NOTE) (NAME . |A#6|) (VALUE . 94) (SOLFEGE . TE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . C6) (VALUE . 96) (SOLFEGE . DO) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . D6) (VALUE . 98) (SOLFEGE . RE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |D#6|) (VALUE . 99) (SOLFEGE . ME) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . F6) (VALUE . 101) (SOLFEGE . FA) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . G6) (VALUE . 103) (SOLFEGE . SO) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |G#6|) (VALUE . 104) (SOLFEGE . LE) (OCTAVE . 6))
    ((TYPE . NOTE) (NAME . |A#7|) (VALUE . 106) (SOLFEGE . TE) (OCTAVE . 7))
    ((TYPE . NOTE) (NAME . C7) (VALUE . 108) (SOLFEGE . DO) (OCTAVE . 7)))
   (TEMPLATE (W . DO) (H . RE) (W . ME) (W . FA) (H . SO) (W . LE) (W . TE)))
  #+end_example

**** #'scale-notes

Returns a list of all scale notes.

  #+begin_src lisp :package ld-music :exports both
  (take 12 (scale-notes (make-scale 'c4)))
  #+end_src

  #+RESULTS:
  | (TYPE . NOTE) | (NAME . A0) | (VALUE . 21) | (SOLFEGE . LA) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . B0) | (VALUE . 23) | (SOLFEGE . TI) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . C0) | (VALUE . 24) | (SOLFEGE . DO) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . D0) | (VALUE . 26) | (SOLFEGE . RE) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . E0) | (VALUE . 28) | (SOLFEGE . MI) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . F0) | (VALUE . 29) | (SOLFEGE . FA) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . G0) | (VALUE . 31) | (SOLFEGE . SO) | (OCTAVE . 0) |
  | (TYPE . NOTE) | (NAME . A1) | (VALUE . 33) | (SOLFEGE . LA) | (OCTAVE . 1) |
  | (TYPE . NOTE) | (NAME . B1) | (VALUE . 35) | (SOLFEGE . TI) | (OCTAVE . 1) |
  | (TYPE . NOTE) | (NAME . C1) | (VALUE . 36) | (SOLFEGE . DO) | (OCTAVE . 1) |
  | (TYPE . NOTE) | (NAME . D1) | (VALUE . 38) | (SOLFEGE . RE) | (OCTAVE . 1) |
  | (TYPE . NOTE) | (NAME . E1) | (VALUE . 40) | (SOLFEGE . MI) | (OCTAVE . 1) |

**** #'scale-range
Returns a new scale object containing a subset of notes

  #+begin_src lisp :package ld-music :exports both
    (scale-notes (scale-range 'c3 'c4  (make-scale 'c4)))
  #+end_src

  #+RESULTS:
  | (TYPE . NOTE) | (NAME . C3) | (VALUE . 60) | (SOLFEGE . DO) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . D3) | (VALUE . 62) | (SOLFEGE . RE) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . E3) | (VALUE . 64) | (SOLFEGE . MI) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . F3) | (VALUE . 65) | (SOLFEGE . FA) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . G3) | (VALUE . 67) | (SOLFEGE . SO) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . A4) | (VALUE . 69) | (SOLFEGE . LA) | (OCTAVE . 4) |
  | (TYPE . NOTE) | (NAME . B4) | (VALUE . 71) | (SOLFEGE . TI) | (OCTAVE . 4) |
  | (TYPE . NOTE) | (NAME . C4) | (VALUE . 72) | (SOLFEGE . DO) | (OCTAVE . 4) |

**** #'note-range
Returns a subset of notes according to a specified range

  #+begin_src lisp :package ld-music :exports both
    (note-range 'c3 'c4  (scale-notes (make-scale 'c4)))
  #+end_src

  #+RESULTS:
  | (TYPE . NOTE) | (NAME . C3) | (VALUE . 60) | (SOLFEGE . DO) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . D3) | (VALUE . 62) | (SOLFEGE . RE) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . E3) | (VALUE . 64) | (SOLFEGE . MI) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . F3) | (VALUE . 65) | (SOLFEGE . FA) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . G3) | (VALUE . 67) | (SOLFEGE . SO) | (OCTAVE . 3) |
  | (TYPE . NOTE) | (NAME . A4) | (VALUE . 69) | (SOLFEGE . LA) | (OCTAVE . 4) |
  | (TYPE . NOTE) | (NAME . B4) | (VALUE . 71) | (SOLFEGE . TI) | (OCTAVE . 4) |
  | (TYPE . NOTE) | (NAME . C4) | (VALUE . 72) | (SOLFEGE . DO) | (OCTAVE . 4) |


**** #'scale-octaves
Returns an list of pairs (X . Y) where X is a NOTE and Y is an INTEGER
value representing an *octave relative to the scale*.  The idea is
that there is *absolute octaves* and *relative octaves*.

- Absolute is what the piano octaves are like "C4" or "A#7". Absolute isn't related to a key center.
- Relative octaves are relative to the key center/scale... meaning that *a new octave starts on the tonic note*.

  #+begin_src lisp :package ld-music :exports pp
    (take 3 (scale-octaves (scale-notes (make-scale 'c4))))
  #+end_src

  #+RESULTS:
  : ((((TYPE . NOTE) (NAME . A0) (VALUE . 21) (SOLFEGE . LA) (OCTAVE . 0)) . 0) (((TYPE . NOTE) (NAME . B0) (VALUE . 23) (SOLFEGE . TI) (OCTAVE . 0)) . 0) (((TYPE . NOTE) (NAME . C0) (VALUE . 24) (SOLFEGE . DO) (OCTAVE . 0)) . 1))

**** #'with-scale macro
     
** Chord

** Chord Tones

** Scale Chords

* Data and Functions

The initial and most fundamental data we have is a list of MIDI INTEGERS (21..108)

#+begin_src lisp :package ld-music
  (midi-integers)
#+end_src

#+RESULTS:
| 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 |

Then there is the #'midi-note-octave list of absolute note names and octave

 #+begin_src lisp :package ld-music
   (midi-note-octave)
 #+end_src

 #+RESULTS:
 : (A0 |A#0| B0 C0 |C#0| D0 |D#0| E0 F0 |F#0| G0 |G#0| A1 |A#1| B1 C1 |C#1| D1
 :  |D#1| E1 F1 |F#1| G1 |G#1| A2 |A#2| B2 C2 |C#2| D2 |D#2| E2 F2 |F#2| G2 |G#2|
 :  A3 |A#3| B3 C3 |C#3| D3 |D#3| E3 F3 |F#3| G3 |G#3| A4 |A#4| B4 C4 |C#4| D4
 :  |D#4| E4 F4 |F#4| G4 |G#4| A5 |A#5| B5 C5 |C#5| D5 |D#5| E5 F5 |F#5| G5 |G#5|
 :  A6 |A#6| B6 C6 |C#6| D6 |D#6| E6 F6 |F#6| G6 |G#6| A7 |A#7| B7 C7)

 #+begin_src lisp  :package ld-music
   (first (midi-note-octave)) ; A0
   (last (midi-note-octave))  ; (C7)
   (length (midi-note-octave)); 88
 #+end_src

The  #'midi-notes function turns the MIDI integers and absolute note names into the NOTE data structure

#+begin_src lisp  :package ld-music
  (first (midi-notes)); ((TYPE . NOTE) (NAME . A0) (VALUE . 21) (SOLFEGE) (OCTAVE . 0))
  (last (midi-notes)); (((TYPE . NOTE) (NAME . C7) (VALUE . 108) (SOLFEGE) (OCTAVE . 7))) 
  (length (midi-notes)); 88
#+end_src

At this point, we have a basic representation of all notes on the keyboard.
The next step is to build scales.

*Scale templates* are used to realize scales from the patterns they
define. For example, The major scale uses a pattern of "W W H W W W H"
where W is 2 semitones and H is 1 semitone.

The #'make-scale-template function is used to make *scale templates*.

To define the major scale template, set the pattern and the solfege
syllables:

#+begin_src lisp  :package ld-music
  (make-scale-template '(w w h w w w h) '(do re mi fa so la ti do))
#+end_src

#+RESULTS:
: ((W . DO) (W . RE) (H . MI) (W . FA) (W . SO) (W . LA) (H . TI))

To realize the scale, use the *#'make-scale-from-template* function.

The algorithm looks at all notes available and returns only the notes
found according to the scale pattern.

The function signature requires a starting note and end note.

To creates a C major scale from C4 to C5:
#+begin_src lisp  :package ld-music
  (let ((major-scale-template
	  (make-scale-template '(w w h w w w h)
			       '(do re mi fa so la ti do))))
    (make-scale-from-template 'C4 'C5 major-scale-template))
#+end_src

#+RESULTS:
| (TYPE . NOTE) | (NAME . C4) | (VALUE . 72) | (SOLFEGE . DO) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . D4) | (VALUE . 74) | (SOLFEGE . RE) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . E4) | (VALUE . 76) | (SOLFEGE . MI) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . F4) | (VALUE . 77) | (SOLFEGE . FA) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . G4) | (VALUE . 79) | (SOLFEGE . SO) | (OCTAVE . 4) |
| (TYPE . NOTE) | (NAME . A5) | (VALUE . 81) | (SOLFEGE . LA) | (OCTAVE . 5) |
| (TYPE . NOTE) | (NAME . B5) | (VALUE . 83) | (SOLFEGE . TI) | (OCTAVE . 5) |
| (TYPE . NOTE) | (NAME . C5) | (VALUE . 84) | (SOLFEGE . DO) | (OCTAVE . 5) |

Each item in the list is a NOTE -- an ALIST representing SOLFEGENAME,
NOTENAME, MIDI-VALUE, and KEYBOARD OCTAVE.

The functions #'note-name, #'note-value, #'note-solfege are used to
select note data.

** CHORDS
The next logical step would be to build up chords.

The C Major scale notes are C D E F G A B. To make chords, you combine every other note in scale:

The triads in C major are "CEG" "DFA" "EGB" "FAC" "GBD" "ACE" "BDF".

The seventh chords in C major are "CEGA" "DFAG" "EGBD" "FACE" "GBDF" "ACEG" "BDFA".

Use the #'chord-builder function to generate a list of chords.

*#'chord-builder* takes a scale and generates a list of chords up the
the 13th (remember, a chord is just a list of notes)

#+begin_src lisp :package ld-music
  (take 7 (let* ((c-major-scale
	   (make-scale-from-template 'C2 'G4
				     (make-scale-template '(w w h w w w h)
							  '(do re mi fa so la ti do)))))
    (chord-builder c-major-scale)))
#+end_src

#+RESULTS:
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C2) (VALUE . 48) (SOLFEGE . DO) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E2) (VALUE . 52) (SOLFEGE . MI) (OCTAVE . 2)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D2) (VALUE . 50) (SOLFEGE . RE) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E2) (VALUE . 52) (SOLFEGE . MI) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F2) (VALUE . 53) (SOLFEGE . FA) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G2) (VALUE . 55) (SOLFEGE . SO) (OCTAVE . 2)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A3) (VALUE . 57) (SOLFEGE . LA) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C3) (VALUE . 60) (SOLFEGE . DO) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E3) (VALUE . 64) (SOLFEGE . MI) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G3) (VALUE . 67) (SOLFEGE . SO) (OCTAVE . 3)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B4) (VALUE . 71) (SOLFEGE . TI) (OCTAVE . 4)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D4) (VALUE . 74) (SOLFEGE . RE) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F4) (VALUE . 77) (SOLFEGE . FA) (OCTAVE . 4)) (DEGREE . 13)) |
| ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . B3) (VALUE . 59) (SOLFEGE . TI) (OCTAVE . 3)) (DEGREE . 1)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . D3) (VALUE . 62) (SOLFEGE . RE) (OCTAVE . 3)) (DEGREE . 3)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . F3) (VALUE . 65) (SOLFEGE . FA) (OCTAVE . 3)) (DEGREE . 5)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . A4) (VALUE . 69) (SOLFEGE . LA) (OCTAVE . 4)) (DEGREE . 7)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . C4) (VALUE . 72) (SOLFEGE . DO) (OCTAVE . 4)) (DEGREE . 9)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . E4) (VALUE . 76) (SOLFEGE . MI) (OCTAVE . 4)) (DEGREE . 11)) | ((TYPE . CHORD-TONE) (NOTE (TYPE . NOTE) (NAME . G4) (VALUE . 79) (SOLFEGE . SO) (OCTAVE . 4)) (DEGREE . 13)) |

*** Triads and Sevenths
The *#'triads* and *#'sevenths* functions take a list of chords and reduce
each chord to a specific number of notes, 3 and 4 respectively.

The *#'chord-take function* takes an integer and list of chords and returns a shortened list.

#+begin_example
  (car (triads (test-chord-builder))) 
#+end_example
: => (((C2 . 48) . DO) ((E2 . 52) . MI) ((G2. 55) . SO))

#+begin_example
  (car (sevenths (test-chord-builder)))
#+end_example
: => (((C2 . 48) . DO) ((E2 . 52) . MI) ((G2 . 55) . SO) ((B3 . 59) . TI)) 

#+begin_example
(car (chord-take 2 (test-chord-builder)))
#+end_example
: => (((C2 . 48) . DO) ((E2 . 52) . MI))

* Upcoming documentation
** additional chord functions inversions

      #+begin_example
   (defun inversion-test ()
     (chord-play (car (triads (chord-builder (scale-range 'C3 'G5 (make-scale 'c4))))))

     (chord-play (chord-over-3 (car (triads (chord-builder (scale-range 'C3 'G5 (make-scale 'c4)))))  (make-scale 'c4)))

     (chord-play (chord-over-5 (car (triads (chord-builder (scale-range 'C3 'G5 (make-scale 'c4))))) (make-scale 'c4)))

     (chord-play (car (triads (chord-builder (scale-range 'C4 'G5 (make-scale 'c4))))))

     )

    (mapcar #'chord-play (take 8 (triads (modes2 (make-scale-from-template 'C2 'B5 (major-scale-template))))))

   (chord-play (chord-invert (car (chords (scale-range 'c3 'G5 (make-scale 'c4)))) (make-scale 'c4)))

   (chord-invert (chord-remove-degree (chord-upper (car (cdr (chords (scale-range 'c3 'G5 (make-scale 'c4)) #'sevenths)))) 5) (make-scale 'c4))
      #+end_example

** with-scale macro

   #+begin_example
     (with-scale (random-major-scale)
       (play-scale *current-scale*))

     (with-scale (random-major-scale)
       (play-tonic-subdominant-dominant  *current-scale*))

     (with-scale (random-major-scale)
       (play-tonic *current-scale*)
       (sleep 0.5)
       (play-subdominant *current-scale*)
       (sleep 0.5)
       (play-dominant *current-scale*)
       (sleep 0.5)
       (play-tonic *current-scale*))

     (with-scale (random-major-scale)
       (solfege-chord '(DO MI SO) *current-scale*))

     (with-scale (random-major-scale)
       (play-tonic-subdominant-dominant *current-scale*))

     (with-scale (random-major-scale)
       (chord-builder *current-scale*))

     (mapcar #'chord-play (triads (chord-builder (build-scale 'C4 (major-scale-template)))))
     (mapcar #'chord-play (subseq (triads (chord-builder (build-scale 'C4 (major-scale-template)))) 16 24))

   #+end_example

** Chord sequencing
   #+begin_example
     (with-scale (build-scale 'C4 (major-scale-template))
       (play-chords (sevenths (chord-sequence '(I IV V I)
					      (scale-range 'C2 'G3 *current-scale*)))))

     (with-scale (build-scale 'C4 (major-scale-template))
       (let* ((chord-list (take-octaves 2 (chord-builder (scale-range 'A2 'C7 *current-scale*))))
	      (chords (chord-roman-numerals (triads chord-list)))
	      (chord-sequence '(I VI- II- V III- VI- II- V I)))

	 (play-chords (mapcar (lambda (rn)
				(find-chord rn chords))
			      chord-sequence))))

     (chord-sequence-play
      (chord-sequence-chords
       (chord-sequence
	'((octave . 3) I (octave . 3) VI- (octave . 3)  II- (octave . 2) V (octave . 3) I)
	(chords (make-scale 'C4) #'sevenths))))
   
     (chords (make-scale 'C4) #'sevenths)

   #+end_example

** Solfege chords
   #+begin_example
     (with-scale (scale-range 'C4 'G5 (make-scale 'C4))
      (solfege-chord '(Do mi so) *current-scale*)
      (solfege-chord '(re fa la) *current-scale*)
      (solfege-chord '(mi so ti) *current-scale*)
      (arp '(do mi so) *current-scale*)
      (rarp '(do mi so) *current-scale*))

   #+end_example

** Threading function
   #+begin_example
     (-> (make-scale-chords (make-scale 'C2))
	 (scale-chord-filter #'chord-type-filter #'ninths)
	 (scale-chord-filter #'chord-filter #'chord-butfifth)
	 (scale-chord-filter #'chord-filter #'chord-droproot)
	 (chord-seq '(II-
		      (octave . 2)
		      V
		      (octave . 3)
		      I
		      (octave . 3)
		      VI-
		      (octave . 3)
		      II-
		      (octave . 2)
		      V
		      (octave . 3)
		      I
		      I
		      ) 3))

	   #'chord-seq-play)
   #+end_example

** Games
   
*** Solfege trainer

*** Melody Game

*** Bass Game

* Files
** note
- note representation and functions
   #+begin_src sh :exports results :results pp
   grep defun src/note.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun note-name-position (note-name &optional (scale (midi-notes)))
   (defun find-note-in-octave (note scale)
   (defun note-attr (note attr) (cdr (assoc attr note)))
   (defun note-name (note) (note-attr note 'name))
   (defun note-value (note) (note-attr note 'value))
   (defun note-solfege (note) (note-attr note 'solfege))
   (defun note-equal-p (x y)
   (defun note-idx (note &optional (scale (midi-notes)))
   (defun note-octave-up (note scale)
   (defun note-octave-down (note scale)
   (defun parse-note-octave (note-name)
   (defun find-note (name &optional (scale (midi-notes)))
   (defun make-note (name value solfege)
   #+end_example

** scale
Funcations for making scales and scale templates representation.

   #+begin_src sh :exports results :results pp
   grep defun src/scale.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun make-scale-template (steps solfege)
   (defun chromatic-scale-template ()
   (defun major-scale-template () (make-scale-template '(w w h w w w h) '(do re mi fa so la ti) ))
   (defun minor-scale-template () (make-scale-template '(w h w w h w w) '(do re me fa so le te)))
   (defun dorian-scale-template () (make-scale-template '(w h w w w h w) '(do re me fa so la ti)))
   (defun phrygian-scale-template () (make-scale-template '(h w w w h w) '(do ra me fa so le te)))
   (defun scale-range (n1 n2 scale)
   (defun make-scale-from-template (p1 p2 scale-template)
   (defun build-scale-up (from-note-pos pattern)
   (defun build-scale-down (from-note-pos pattern)
   (defun assign-solfege (scale scale-template)
   (defun build-scale (start-note pattern &optional (notes (midi-notes)))
   (defun random-scale (template)
   (defun random-scale2 (template)
   (defun random-major-scale () (random-scale (major-scale-template)))
   (defun random-major-scale2 () (random-scale2 (major-scale-template)))
   (defun random-chromatic-scale () (random-scale2 (chromatic-scale-template )))
   (defun scale-notes (scale)
   (defun make-scale (scale-root &optional (template (major-scale-template)))
   (defun scale-range2 (p1 p2 scale-data)
   (defun scale-octaves (scale &optional (count 0))
   (defun midi-notes-from-scale (midi-notes original-scale scale)
   (defun midi-notes-from-scale-down-helper (midi-notes original-scale scale)
   (defun with-scale-helper (scale my-fn)
   (defun random-note (scale) (nth (random (length scale)) scale))
   (defun random-notes (y scale) (loop for x from 1 to y collect (random-note scale)))
   (defun solfege-chord (l scale)
   (defun find-solfege (solfege lis)
   (defun solfege->notes (scale solfege-list)
   ;; (defun major-scales ()
   ;; (defun spell-scale (root)
   #+end_example

** chord
Chord representation and functions

   #+begin_src sh :exports results :results pp
   grep defun src/chord.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun find-chord (octave romand-num chord-list scale)
   (defun make-chord-tone (note degree)
   (defun chord-tone-note (chord-tone)(attr 'note chord-tone))
   (defun chord-degree (chord-tone) (attr 'degree chord-tone))
   (defun chord-notes (chord) (mapcar #'chord-tone-note chord))
   (defun chord-builder (l)
   (defun make-chords (start-note &optional (filter-fn #'triads) (template (major-scale-template)))
   (defun make-scale-chords (scale)
   (defun scale-chords (scale-chord-data) (attr 'chords scale-chord-data))
   (defun chord-sequence-chords (chord-sequence) (mapcdr chord-sequence))
   (defun chord-root (chord)
   (defun chord-sequence-play (chord-sequence &optional (sleep 1))
   (defun chord-butroot (chord) (chord-remove-degree chord 1))
   (defun chord-butfifth (chord) (chord-remove-degree chord 5))
   (defun chord-drop-root (chord scale) 
   (defun chord-invert-upper (chord)
   (defun chord-tone-degree (chord-tone) (attr 'degree chord-tone))
   (defun chord-remove-degree (chord degree)
   (defun chord-take (n listofchords)
   (defun triads (myl) (chord-take 3 myl))
   (defun sevenths (myl) (chord-take 4 myl))
   (defun ninths (myl) (chord-take 5 myl))
   (defun elevenths (myl) (chord-take 6 myl))
   (defun thirteenths (myl) (chord-take 7 myl))
   (defun chord-invert (chord scale)
   (defun chord-over-3 (root-position-chord scale)
   (defun chord-over-5 (root-position-chord scale)
   (defun major-solfege-chords ()
   (defun chord-roman-numerals (chord-list)
   (defun chord-sequence (chord-sequence chords scale &optional (octave 4))
   (defun scale-chord-filter (fn &rest args)
   (defun rebuild-chords ()
   (defun octave-filter (octave)
   (defun chord-filter (fn)
   (defun chord-type-filter (fn)
   (defun chord-seq (seq &optional (octave 4))
   #+end_example

** rhythm
Logic for calculating rhythm durations based on BPM   

   #+begin_src sh :exports results :results pp
   grep defun src/rhythm.lisp
   #+end_src

   #+RESULTS:
   : (defun make-rhythmic-notes (notes rhythm-list)
   : (defun rhythm->duration-scaled (r bpm)
   : (defun beat-length (beat bpm)
   : (defun rhythm->seconds (r bpm)
   : (defun rhythm-values (r)

** event
Functions for representing an EVENT (NOTE ON-TIME OFF-TIME VELOCITY)
and for playing an event (via portmidi).

   #+begin_src sh :exports results :results pp
   grep defun src/event.lisp
   #+end_src

   #+RESULTS:
   : (defun make-event (note on-time off-time velocity)
   : (defun play-event (event)
   : (defun play-events (events)

** util
- Utility functions

   #+begin_src sh :exports results :results pp
   grep defun src/util.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun fdbug (code)
   (defun mapcdr (seq) (mapcar #'cdr seq))
   (defun attr (item alist) (cdr (assoc item alist)))
   (defun attr= (value item alist) (setf (cdr (assoc item alist)) value))
   (defun random-element (l) (nth (random (length l)) l))
   (defun take (n l) (subseq l 0 n))
   (defun prepend-tail (lis) (append (last lis) (butlast lis)))
   (defun attrs (item &rest attrlist)
   (defun -> (item &rest fns)
   (defun grow (l1 l2 &optional (idx 0))
   (defun pairup (l1 l2)
   (defun shuffle (sequence &optional (seed (make-random-state t)))
   (defun any? (i l)
   (defun lcontains-p (lx l)
   (defun every-p (lx l)
   (defun find-all-if (pred sequ &rest keyword-args &key &allow-other-keys)
   ;; (defun rotate (scale) (append (cdr scale) (list (car scale))))
   ;; (defun rotate-n (n scale)
   (defun map-idx (s)
   (defun car-eq (item other)
   (defun car-fn (fn args)
   (defun flatten (structure)
   #+end_example

** midi :cleanup:
- Lower-level midi functions

   #+begin_src sh :exports results :results pp
   grep defun src/midi.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun pm-reload (midi-device-id)
   (defun ensure-midi ()
   (defun pm-terminate ()
   (defun pm-initialize (midi-device-id)
   (defun midi-instruments () '(
   (defun midi-note-octave ()
   (defun midi-integers () (loop for x from 0 to 87 collect (+ 21 x)))
   (defun midi-notes ()
   (defun make-message (status data1 data2)
   (defun make-message* (upper lower data1 data2) ;internal
   (defun program-change (program &optional (channel 1) (stream *midi-out3*))
   (defun panic (&optional (channel 1))
   (defun note-on (value &optional (velocity 80) (channel 0) (stream *midi-out3*))
   (defun note-off (value &optional (channel 0) (stream *midi-out3*))
   (defun notes-on (values &optional (velocity 80) (channel 0) (stream *midi-out3*))
   (defun notes-off (values &optional (channel 0) (stream *midi-out3*))
   (defun note-play (note &optional (velocity 80) (channel 1))
   (defun note-stop (note &optional (channel 1))
   (defun note-play-sleep (note)
   (defun write-midi-file-format-0 (outfile midi-notes)
   (defun write-midi-file-format-1 (outfile midi-notes &optional (division 60))
   #+end_example

** play
- NEEDS CLEANUP
- functions for playing notes

   #+begin_src sh :exports results :results pp
   grep defun src/play.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun play-random (scale) (note-play (car (random-note scale))))
   (defun chord-play (chord &optional (sleep 1))
   (defun play-chords (chords)
   (defun arp (l scale)
   (defun rarp (l scale)
   (defun play-tonic (scale) (note-play (car scale)))
   (defun play-subdominant (scale) (note-play (nth 3 scale)))
   (defun play-dominant (scale) (note-play (nth 4 scale)))
   (defun tonic-subdominant-dominant2 (scale)
   (defun tonic-subdominant-dominant (scale)
   (defun play-tonic-subdominant-dominant (scale)
   (defun smoke-test ()
   #+end_example

** sequencer
- logic for generating/writing midi sequences to file via the MIDI library
- logic for generating midi sequences for portmidi

   #+begin_src sh :exports results :results pp
   grep defun src/sequencer.lisp
   #+end_src

   #+RESULTS:
   : (defun schedule (time fn &rest args)
   : (defun schedule-note (note &optional (on-time 0) off-time (velocity 80))
   : (defun note->midi-message (note time-on time-off &optional (*midi-channel* 0))
   : (defun midi-timing-track (bpm &optional (*midi-channel* 9))
   : (defun midi-seq-format-1 (rhythmic-notes &optional (bpm 60))
   : (defun midi-seq-format-0 (notes)
   : (defun rhythmic-notes->midi-messages (notes/rhythms bpm)
   : (defun rhythmic-notes->pm-events (notes/rhythms bpm &optional (*midi-channel* 0))

** games
- initial logic/functions to support games

   #+begin_src sh :exports results :results pp
   grep defun src/games.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun make-game (name logic-fn)
   (defun play-game ()
   (defun update-game-lst (key item game)
   (defun my-play-game (game)
   (defun find-answers (type game)
   (defun find-unique-answers (type game)
   (defun repeat-answers (type game)
   (defun update-score (score game)
   (defun read-guess () (mapcar #'intern (cl-ppcre:split "\\s+" (read-line))))
   (defun set-bass-scale ()
   (defun play-bass-game ()
   (defun solfege-trainer ()
   (defun play-melody-game ()
   (defun play-chord-trainer ()
   (defun prompt-guess (answer game current-scale)
   (defun prompt-bass-guess (answer game scale)
   (defun prompt-chord-guess (answer game scale)
   (defun run-chord-trainer (game)
   (defun run-melody-game (game)
   (defun run-bass-game (game)
   (defun run-game ()
   (defun score ()
   (defun stop-game (game)
   (defun reset-game ()
   #+end_example

** random :cleanup:
- NEEDS CLEANUP
- functions for generating random notes / experimenting with note resolutions / cadences

   #+begin_src sh :exports results :results pp
   grep defun src/random.lisp
   #+end_src

   #+RESULTS:
   #+begin_example
   (defun find-prev-do-helper (idx scale)
   (defun find-prev-do (note scale)
   (defun resolve-down (note scale)
   (defun resolve-note (note scale)
   (defun note-to-do (note scale)
   (defun remove-after-do (scale)
   (defun random-notes ()
   (defun random-chromatic ()
   (defun scale-octave-range-helper (o1 o2 scale)
   (defun scale-octave-range (o1 o2 notes)
   (defun play-tonic-subdominant-dominant2 (scale)
   (defun play-tonic-subdominant-dominant3 (scale)
   (defun sing-do ()
   (defun random-chromatic2 ()
   (defun random-chromatic3 ()
   (defun notes->midi ()
   #+end_example

** package
- Defines the package and exports

** output.lisp
- Should be taken out of this library.

* Issues
  - setting slot-value 'midi:dd/nn/cc/bb doesn't work out of the box
    because not exported. had to fork cl-midi library and add exports
  - update local cl-portmidi library to get updates and remove
    make-message* fns as make-message now exported
  - work on setting up exports in ASD file
  - should every file be in the same namespace?
  - scale templates can be defined as VARS instead of functions
  - consider using chromatic scale by default in scale logic and deducing other scales from that 
